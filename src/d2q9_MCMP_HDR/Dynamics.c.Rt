// 18/7/2016 - Model Developed: Jie Bao and Laura Schaefer
// """"Lattice Boltzmann equation model for multi-component multi-phase
//     flow with high density ratios""""
// i.e. MCMP_HDR = multicomponent multiphase_High Density Ratio
// e.g. files start with d2q9_MCMP
// Maintainer: Travis-Mitchell @TravisMitchell

// Code updates:
//		18/07/16 - Weighting of c0 parameter altered such that weights
//				  are equivalent of lattice weights (seems to be more
//				  stable).
//		02/08/16 - Change model name for detail.
<?R
#region R code Preamble
	source("conf.R") 
	c_header();
	
	source("lib/feq.R")
	source("lib/boundary.R")

# First Population (f) - wet
	U = t(as.matrix(rbind( Density$dx[Density$group=='f'], Density$dy[Density$group=='f'] ) ))
	EQ = MRT_eq(U, ortogonal=FALSE)
    wi = subst(EQ$Req, Jx=0, Jy=0, Jz=0)
    wi = subst(wi, rho=1)
    wi = gapply(wi,function(x) x$.M, simplify=TRUE)
    wi = wi %*% solve(EQ$mat)
	wi = as.vector(wi)
	W = solve(EQ$mat) %*% diag(1/wi) %*% solve(t(EQ$mat))
	i = rev(1:nrow(W))
	H = chol(W[i,i])[i,i]
	H = H * c(1,sqrt(3)/3,sqrt(3)/3,sqrt(2),sqrt(2),1,sqrt(6)/3,sqrt(6)/3,2)
	B = EQ$mat %*% t(H)
	EQ = MRT_eq(U, mat=B)
	f = PV(Density$name[Density$group=='f'])
	rho = PV("rho")
	J = PV("J",c("x","y"))
# Secong Population (g) - dry
	U_g = t(as.matrix(rbind( Density$dx[Density$group=='g'], Density$dy[Density$group=='g'] ) ))
	EQ_g = MRT_eq(U_g, ortogonal=FALSE)
    wi_g = subst(EQ_g$Req, Jx=0, Jy=0, Jz=0)
    wi_g = subst(wi_g, rho=1)
    wi_g = gapply(wi_g,function(x) x$.M, simplify=TRUE)
    wi_g = wi_g %*% solve(EQ_g$mat)
	wi_g = as.vector(wi_g)
	W_g = solve(EQ_g$mat) %*% diag(1/wi_g) %*% solve(t(EQ_g$mat))
	i_g = rev(1:nrow(W_g))
	H_g = chol(W[i_g,i_g])[i_g,i_g]
	H_g = H_g * c(1,sqrt(3)/3,sqrt(3)/3,sqrt(2),sqrt(2),1,sqrt(6)/3,sqrt(6)/3,2)
	B_g = EQ_g$mat %*% t(H_g)
	EQ_g = MRT_eq(U_g, mat=B_g)
	g = PV(Density$name[Density$group=='g'])
	rho = PV("rho")
	J = PV("J",c("x","y"))
#endregion R code Preamble
?>
<?python
#region python preamble
from sympy import *
from sympy.printing import print_ccode
G = var(['G11','G12','G21','G22'])
ueq_f = var(['ueq_f.x', 'ueq_f.y'])
ueq_g = var(['ueq_g.x', 'ueq_g.y'])
rho = var(['rf', 'rg'])
om  = var(['omega', 'omega_g'])
Densities = var(Density['name'])
R = var(['R[0]','R[1]','R[2]','R[3]','R[4]','R[5]','R[6]','R[7]','R[8]'])
w0 = 4/9.0
w1 = 1/9.0
w2 = 1/36.0
w  = [w0, w1, w1, w1, w1, w2, w2, w2, w2]
cx = [0, 1, 0, -1, 0, 1, -1, -1, 1]
cy = [0, 0, 1, 0, -1, 1, 1, -1, -1]
feq= [0, 0, 0, 0,  0, 0, 0,  0,  0]
psi_f=[0, 0, 0, 0,  0, 0, 0,  0,  0]
psi_g=[0, 0, 0, 0,  0, 0, 0,  0,  0]
for i in range(9):
	psi_f[i]= var(str('psi_f(' + str(cx[i]) + ',' + str(cy[i]) + ')'))
	psi_g[i]= var(str('psi_g(' + str(cx[i]) + ',' + str(cy[i]) + ')')) 
u   = var(['u.x', 'u.y'])
u1  = var([['uf.x', 'uf.y'],['ug.x', 'ug.y']])
#endregion python preamble
?>
#define pi 3.141592653589793116

CudaDeviceFunction real_t getRhof(){
	return <?R C(sum(f)) ?> ;
}
CudaDeviceFunction real_t getRhog(){
	return <?R C(sum(g)) ?> ;
}  
CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)+sum(g)) ?> ;
}  

CudaDeviceFunction vector_t getU(){
	real_t rf = <?R C(sum(f)) ?>;
	vector_t u;
	vector_t F = getFf();
	u.x = ((f[1] - f[3] + f[5] - f[6] - f[7] + f[8]) + F.x*0.5)/rf;
	u.y = ((f[2] - f[4] + f[5] + f[6] - f[7] - f[8]) + F.y*0.5)/rf;
	u.z = 0.0;
		return u;
}
CudaDeviceFunction vector_t getUg(){
	real_t rg = <?R C(sum(g)) ?>;
	vector_t u;
	vector_t F = getFg();
	u.x = ((g[1] - g[3] + g[5] - g[6] - g[7] + g[8]) + F.x*0.5)/rg;
	u.y = ((g[2] - g[4] + g[5] + g[6] - g[7] - g[8]) + F.y*0.5)/rg;
	u.z = 0.0;
		return u;
}
CudaDeviceFunction vector_t getUc(){
	// Common velocity
	real_t rf = <?R C(sum(f)) ?>;
	real_t rg = <?R C(sum(g)) ?>;
	vector_t u;
<?python
numx = 0.0   #numerator for x direction
denxy = 0.0  #denominator for x,y direction
numy = 0.0   #numerator for y direction
for i in range(2):
	denxy += rho[i]*om[i]
	for j in range(9):
		ind = i*9+j
		numx += Densities[ind] * cx[j] * om[i]
		numy += Densities[ind] * cy[j] * om[i]
print_ccode(numx/denxy, assign_to=u[0])
print_ccode(numy/denxy, assign_to=u[1])
?>	
	u.z = 0.0;
		return u;
}
CudaDeviceFunction real_t getP(){
	//TO DO: this will need to be updated when EoS implemented
		real_t rf  = <?R C(sum(f))?>;
		real_t rg  = <?R C(sum(g))?>;
		return EoS_PR(rf,a1,b1,R1,omega_PR1)+EoS_PR(rg,a2,b2,R2,omega_PR2);
}

/*CudaDeviceFunction real_t EoS_CS(real_t d){
	real_t p;
	real_t Tc=0.0943;
	real_t temp_bp = b*d/4.0;
	p = d*R*T*Tc*(1+temp_bp+temp_bp*temp_bp-temp_bp*temp_bp*temp_bp);
	p = p/((1-temp_bp)*(1-temp_bp)*(1-temp_bp));
	p = p - a*d*d;
	return p;
}*/
CudaDeviceFunction real_t EoS_PR(real_t d,real_t a,real_t b,real_t R,real_t omega_PR){
	real_t p;
	real_t Tc=0.0729220041;//a/(b*R*5.877120823);
	real_t alpha = pow( (1.0+(0.37464+1.54226*omega_PR-0.26992*omega_PR*omega_PR)*(1-sqrt(T))) ,2);

	p = d*R*T*Tc/(1.0-b*d) - a*alpha*d*d/(1.0+2.0*b*d-b*b*d*d);
	return p;
}

CudaDeviceFunction vector_t getFf(){
	vector_t Force;
	real_t d = <?R C(sum(f)) ?> ;
	real_t F_fgx, F_fgy, F_ffx, F_ffy, F_wx, F_wy;
//TO DO: Add in surface tension control:	real_t F_sx, F_sy;
	Force.x = 0.0;
	Force.y = 0.0;
	Force.z = 0.0;
	
	real_t c0 = 1.0/3.0, c1 = 1.0/3.0, c2 = 1.0/12.0;
	
	F_ffx = -c0 * psi_f(0,0) * G11 * (c1*(psi_f(1,0)-psi_f(-1,0)) + c2*(psi_f(1,1)-psi_f(-1,1)+psi_f(1,-1)-psi_f(-1,-1)));
	F_ffy = -c0 * psi_f(0,0) * G11 * (c1*(psi_f(0,1)-psi_f(0,-1)) + c2*(psi_f(1,1)+psi_f(-1,1)-psi_f(1,-1)-psi_f(-1,-1)));
	
	F_fgx = -c0 * psi_f(0,0) * G12 * (c1*(psi_g(1,0)-psi_g(-1,0)) + c2*(psi_g(1,1)-psi_g(-1,1)+psi_g(1,-1)-psi_g(-1,-1)));
	F_fgy = -c0 * psi_f(0,0) * G12 * (c1*(psi_g(0,1)-psi_g(0,-1)) + c2*(psi_g(1,1)+psi_g(-1,1)-psi_g(1,-1)-psi_g(-1,-1)));

	F_wx = -d * Gw1 * (rho_w(1,0) - rho_w(-1,0) + rho_w(1,1) - rho_w(-1,1) - rho_w(-1,-1) + rho_w(1,-1));
	F_wy = -d * Gw1 * (rho_w(0,1) - rho_w(0,-1) + rho_w(1,1) + rho_w(-1,1) - rho_w(-1,-1) + rho_w(1,-1));
	
/*	F_sx = 
	F_sy = */

	Force.x = F_ffx + F_fgx + F_wx + d*GravitationX;
	Force.y = F_ffy + F_fgy + F_wy + d*GravitationY;
	
	return Force;
}
CudaDeviceFunction vector_t getFg(){
	vector_t Force;
	real_t d = <?R C(sum(g)) ?> ;
	real_t F_gfx, F_gfy, F_ggx, F_ggy, F_wx, F_wy;
	Force.x = 0.0;
	Force.y = 0.0;
	Force.z = 0.0;
	
	real_t c0 = 1.0/3.0, c1 = 1.0/3.0, c2 = 1.0/12.0;
	
	F_ggx = -c0 * psi_g(0,0) * G22 * (c1*(psi_g(1,0)-psi_g(-1,0)) + c2*(psi_g(1,1)-psi_g(-1,1)+psi_g(1,-1)-psi_g(-1,-1)));
	F_ggy = -c0 * psi_g(0,0) * G22 * (c1*(psi_g(0,1)-psi_g(0,-1)) + c2*(psi_g(1,1)+psi_g(-1,1)-psi_g(1,-1)-psi_g(-1,-1)));
	
	F_gfx = -c0 * psi_g(0,0) * G21 * (c1*(psi_f(1,0)-psi_f(-1,0)) + c2*(psi_f(1,1)-psi_f(-1,1)+psi_f(1,-1)-psi_f(-1,-1)));
	F_gfy = -c0 * psi_g(0,0) * G21 * (c1*(psi_f(0,1)-psi_f(0,-1)) + c2*(psi_f(1,1)+psi_f(-1,1)-psi_f(1,-1)-psi_f(-1,-1)));

	F_wx = -d * Gw2 * (rho_w(1,0) - rho_w(-1,0) + rho_w(1,1) - rho_w(-1,1) - rho_w(-1,-1) + rho_w(1,-1));
	F_wy = -d * Gw2 * (rho_w(0,1) - rho_w(0,-1) + rho_w(1,1) + rho_w(-1,1) - rho_w(-1,-1) + rho_w(1,-1));
	
	Force.x = F_ggx + F_gfx + F_wx + d*GravitationX_g;
	Force.y = F_ggy + F_gfy + F_wy + d*GravitationY_g;
	
	return Force;
}
CudaDeviceFunction void CalcPsi_f(){
	real_t d = <?R C(sum(f)) ?> ;
	real_t p = EoS_PR(d, a1, b1, R1, omega_PR1 );
	real_t c0 = G11/3.0; 
	psi_f = sqrt( fabs(2.0*(p-d/3.0) / c0 )) ;
	if (NodeType & NODE_Wall)
	{
		psi_f = 0.0;
	}
	//printf("Density2 %f, pressure %f, Value of psi %f, c0 %f\n", d, p, psi_f, c0);
}
CudaDeviceFunction void CalcPsi_g(){
	real_t d = <?R C(sum(g)) ?> ;
	real_t p = EoS_PR(d, a2, b2, R2, omega_PR2 );
	real_t c0 = G22/3.0; 
	psi_g = sqrt( fabs(2.0*(p-d/3.0) / c0 )) ;
	if (NodeType & NODE_Wall)
	{
		psi_g = 0.0;
	}
}

CudaDeviceFunction real_t getPsi_f(){
	return psi_f(0,0);
}

CudaDeviceFunction void SetEquilibrumf(real_t rho, real_t Jx, real_t Jy){
	if (rho > 0.0001){
<?R
	feq = EQ$Req %*% solve(EQ$mat)
	C( f, feq)
?>}
	else {
<?python
for i in range(9):
	print_ccode(0.0, assign_to=Densities[i])
?>
	}
}
CudaDeviceFunction void SetEquilibrumg(real_t rho, real_t Jx, real_t Jy){
	if (rho > 0.0001){
<?R
	geq = EQ_g$Req %*% solve(EQ_g$mat)
	C( g, geq)
?>}
	else {
<?python
for i in range(9,18):
	print_ccode(0.0, assign_to=Densities[i])
?>
	}
}

CudaDeviceFunction void Init() {
	real_t ux, uy;
	real_t rho_f, ux_f, uy_f;
	real_t rho_g, ux_g, uy_g;
	rho_f = Density;
	rho_g = Density_dry;
	if (SL_L > 0) {
		if (Y < SL_L/2) {
			ux = SL_U * tanh(SL_lambda * ( Y/SL_L - 0.25 ));
		} else {
			ux = SL_U * tanh(SL_lambda * ( 0.75 - Y/SL_L ));
		}
		uy = SL_delta * SL_U * sin(2*pi*(X/SL_L+0.25));
	} else {
		ux=0;
		uy=0;
	}
	ux_f = Velocity_f+ux;
	uy_f = uy;
	ux_g = Velocity_g+ux;
	uy_g = uy;
	if (NodeType & NODE_Wall){
		SetEquilibrumf(0,0,0);
		SetEquilibrumg(0,0,0);
		rho_w = 1.0;
	}
	else {
		rho_w = 0.0;
		SetEquilibrumf(
			rho_f,
			ux_f*rho_f,
			uy_f*rho_f		);
		SetEquilibrumg(
			rho_g,
			ux_g*rho_g,
			uy_g*rho_g		);
	}
}

CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
	case NODE_EVelocity:
		EVelocity();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
    }
    if (NodeType & NODE_BGK)
    {
		CollisionBGK();
    }
}

CudaDeviceFunction void CollisionBGK(){
	real_t rg = <?R C(sum(g)) ?>;
	real_t rf = <?R C(sum(f)) ?>;
	//vector_t u_common  = getU();
	vector_t Force_f = getFf();
	vector_t Force_g = getFg();
	//vector_t ueq_f = getUc();
	//vector_t ueq_g = getUc();
	vector_t ueq_f, ueq_g;
	ueq_f.z = 0.0;
	ueq_g.z = 0.0;
	
	//For Buoyancy in the liquid pop
	if (rf < DensCutOff_h)
	{ Force_f.x += buoyancyX * rf;
	  Force_f.y += buoyancyY * rf;	
	}
	if (rg > DensCutOff_g)
	{ Force_g.x += buoyancyX * rg;
	  Force_g.y += buoyancyY * rf;
	}
	if (rf > 0.0){
		//ueq_f.x += Force_f.x/(omega*rf);
		//ueq_f.y += Force_f.y/(omega*rf);
		ueq_f.x = (f[1]-f[3]+f[5]-f[6]-f[7]+f[8])/rf + Force_f.x/(omega*rf);  //u_common.x + Force_f.x/(omega * rf);
		ueq_f.y = (f[2]-f[4]+f[5]+f[6]-f[7]-f[8])/rf + Force_f.y/(omega*rf);	} //u_common.y + Force_f.y/(omega * rf);}
	else {
		ueq_f.x = 0.0;  //u_common.x;
		ueq_f.y = 0.0; //u_common.y;
		}
	if (rg > 0.0){
		//ueq_g.x += Force_g.x/(omega_g*rg);
		//ueq_g.y += Force_g.y/(omega_g*rg);
		ueq_g.x = (g[1]-g[3]+g[5]-g[6]-g[7]+g[8])/rg + Force_g.x/(omega_g*rg) ; //u_common.x + Force_g.x/(omega_g * rg);
		ueq_g.y = (g[2]-g[4]+g[5]+g[6]-g[7]-g[8])/rg + Force_g.y/(omega_g*rg) ; }//u_common.y + Force_g.y/(omega_g * rg);}
	else{
		ueq_g.x = 0.0;
		ueq_g.y = 0.0;
		}
	
<?python
for i in range(9):
	cdotu = cx[i]*ueq_f[0] + cy[i]*ueq_f[1]
	umag  = ueq_f[0]*ueq_f[0] + ueq_f[1]*ueq_f[1]
	feq[i] = w[i]*rho[0]*(1.0 + (cdotu)*3.0 + (cdotu**2)*4.5 - 1.5*umag)
	collide = Densities[i] - om[0]*(Densities[i] - feq[i])
	print_ccode(collide, assign_to=Densities[i]) 
for i in range(9):
	cdotu = cx[i]*ueq_g[0] + cy[i]*ueq_g[1]
	umag  = ueq_g[0]*ueq_g[0] + ueq_g[1]*ueq_g[1]
	feq[i] = w[i]*rho[1]*(1.0 + (cdotu)*3.0 + (cdotu**2)*4.5 - 1.5*umag)
	collide = Densities[i+9] - om[1]*(Densities[i+9] - feq[i])
	print_ccode(collide, assign_to=Densities[i+9]) 
?>
AddToTotalDensity1(rf);
AddToTotalDensity2(rg);
}


CudaDeviceFunction void BounceBack()
{
<?R FullBounceBack() ?>
}

CudaDeviceFunction void EVelocity()
{
	real_t Velocity = Velocity_f;
<?R 
	ZouHe(EQ, 1, -1, "velocity",f) 
?>
	Velocity = Velocity_g;
<?R
    ZouHe(EQ_g, 1, -1,"velocity",g,predefined="true") 
?>
}

CudaDeviceFunction void WPressure()
{
	real_t Pressure = Pressure_f;
<?R 
	ZouHe(EQ, 1, 1, "pressure",f) 
?>
	Pressure = Pressure_g;
<?R
	ZouHe(EQ_g, 1, 1, "pressure",g,predefined="true")
?>
}

CudaDeviceFunction void WVelocity()
{
	real_t Velocity = Velocity_f;
<?R 
	ZouHe(EQ, 1, 1, "velocity",f)
?>
	Velocity = Velocity_g;
<?R
	ZouHe(EQ_g, 1, 1, "velocity",g,predefined="true")
?>
}

CudaDeviceFunction void EPressure()
{
	real_t Pressure = Pressure_f;
<?R 
	ZouHe(EQ, 1, -1, "pressure",f) 
?>
	Pressure = Pressure_g;
<?R
	ZouHe(EQ_g, 1, -1, "pressure",g,predefined="true")
?>
}



CudaDeviceFunction void CollisionMRT(){
	vector_t u = getU();
<?R
#region first population
	MI = solve(EQ$mat)
	P = MI %*% diag(1/wi) %*% t(MI)

	R = PV("R", 1:nrow(U)-1);
	selR = EQ$order > 1
	R[!selR] = EQ$Req[!selR]
?>
	real_t <?R C(R,sep=",") ?>;
	real_t gamma  = 1-omega;
<?R
	S = PV("S",1:nrow(U)-1);
	S[EQ$order <= 2] = PV("gamma")
	S[EQ$order >  2] = PV("gamma2")


	C( R, f %*% EQ$mat );
	C( R[selR], (R - EQ$Req)[selR]);
?>
	
    vector_t F_f = getFf();
    Jx = u.x + omega * F_f.x ;
    Jy = u.y + omega * F_f.y ;
    
	if (NodeType & NODE_LES) {
		real_t Q, tau, tau0;
<?R
	Rneq = R; Rneq[EQ$order < 2] = 0

	p = PV(c("x","y")); dim(p) = c(2,1)
	Q = p %*% t(p)
	Q = subst(Q,x=U[,1],y=U[,2])
	Q = Q %*% (Rneq %*% solve(EQ$mat))
	C(PV("Q"), sum(Q^2))
?>
		Q = 18.* sqrt(Q) * Smag;
		tau0 = 1/(1-gamma);
		tau = tau0*tau0 + Q;
		tau = sqrt(tau);
		tau = (tau + tau0)/2;
		gamma = 1. - 1./tau;
	}
	real_t gamma2 = gamma;
	if (NodeType & NODE_ENTROPIC) {
		real_t a,b;
<?R
	dh = R; dh[EQ$order <= 2] = 0
	ds = R; ds[EQ$order != 2] = 0

	C( PV("a"), ds %*% P %*% dh)
	C( PV("b"), dh %*% P %*% dh)
?>
		gamma2 = - gamma2 * a/b;
	}
<?R

	C( R[selR], (R * S)[selR]);
	C( R[selR], (R + EQ$Req)[selR]);

	C( f, R %*% solve(EQ$mat), float=F);
 #endregion first population
?>

<?R
#region second population
	MI = solve(EQ_g$mat)
	P = MI %*% diag(1/wi_g) %*% t(MI)

	R = PV("R", 1:nrow(U_g)-1);
	selR = EQ_g$order > 1
	R[!selR] = EQ$Req[!selR]
?>
	gamma  = 1-omega_g;
<?R
	S = PV("S",1:nrow(U_g)-1);
	S[EQ_g$order <= 2] = PV("gamma")
	S[EQ_g$order >  2] = PV("gamma2")


	C( R, g %*% EQ_g$mat );
	C( R[selR], (R - EQ_g$Req)[selR]);
?>
	
	vector_t F_g = getFg();
    Jx = u.x + omega_g * F_g.x ;
    Jy = u.y + omega_g * F_g.y ;
    
	if (NodeType & NODE_LES) {
		real_t Q, tau, tau0;
<?R
	Rneq = R; Rneq[EQ_g$order < 2] = 0

	p = PV(c("x","y")); dim(p) = c(2,1)
	Q = p %*% t(p)
	Q = subst(Q,x=U_g[,1],y=U_g[,2])
	Q = Q %*% (Rneq %*% solve(EQ_g$mat))
	C(PV("Q"), sum(Q^2))
?>
		Q = 18.* sqrt(Q) * Smag;
		tau0 = 1/(1-gamma);
		tau = tau0*tau0 + Q;
		tau = sqrt(tau);
		tau = (tau + tau0)/2;
		gamma = 1. - 1./tau;
	}
	gamma2 = gamma;
	if (NodeType & NODE_ENTROPIC) {
		real_t a,b;
<?R
	dh = R; dh[EQ_g$order <= 2] = 0
	ds = R; ds[EQ_g$order != 2] = 0

	C( PV("a"), ds %*% P %*% dh)
	C( PV("b"), dh %*% P %*% dh)
?>
		gamma2 = - gamma2 * a/b;
	}
<?R

	C( R[selR], (R * S)[selR]);
	C( R[selR], (R + EQ_g$Req)[selR]);

	C( g, R %*% solve(EQ_g$mat), float=F);
#endregion second population
?>
 
}
CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}
CudaDeviceFunction vector_t getA(){
	real_t <?R C(R,sep=",") ?>;
	vector_t ret;
<?R
	C( R, f %*% EQ$mat );
	C( R[selR], (R - EQ$Req)[selR]);
	C( PV("ret.y"), ds %*% P %*% dh)
	C( PV("ret.z"), dh %*% P %*% dh)
?>
	ret.x = ret.y/ret.z;
	return ret;
}
