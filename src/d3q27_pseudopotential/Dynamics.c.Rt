// 25/5/2016 - Model Developed based on Chp 3 of:
// """"Multiphase Lattice Boltzmann methods: Theory and Application""""
// Chp 3: Shan and Chen-type multi-component multiphase models
// i.e. MCMP_base = multicomponent multiphase_base Shan-Chen model
// e.g. files start with d2q9_pp_MCMP
// Maintainer: Travis-Mitchell @TravisMitchell

// Code to be updated to:
/*   High density ratio lattice Boltzmann method simulations of multicomponent
 *   multiphase transport of H2O in air - Stiles and Xue (2016) */
// Edits:
//	4/07/2016 - altered interparticle potential functions and getFf()
// function
//	5/07/2016 - removed reference of math.h library (not allowed)

<?R
#regionRcodePreamble
	source("conf.R") 
	c_header();
	
	source("lib/feq.R")
	source("lib/boundary.R")

	f = PV(DensityAll$name[DensityAll$group=="f"])
	g = PV(DensityAll$name[DensityAll$group=="g"])
	rho =  PV("rho")
	J = PV("J",c("x","y","z"))
	tmp = PV("tmp")

# FirstPopulation(f)-wet
	U = as.matrix(DensityAll[DensityAll$group=="f",c("dx","dy","dz")])
	EQ = MRT_eq(U, rho, J, ortogonal=FALSE);

# SecondPopulation(g)-dry
	U_g = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy","dz")])
	EQ_g = MRT_eq(U_g, rho, J, ortogonal=FALSE);

#endregionRcodePreamble
?>
<?python
#region python preamble
from sympy import *
from sympy.printing import print_ccode
from numpy import zeros
G = var(['G11','G12','G21','G22'])
Gs = var(['Gad1', 'Gad2'])
rho = var(['rf', 'rg'])
om  = var(['omega', 'omega_g'])
Densities = var(Density['name'])
R = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
S = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
psi_f=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
psi_g=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
psi_s=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
feq=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
w0 = 8/27.0
w1 = 2/27.0
w2 = 1/54.0
w3 = 1/216.0
w  = [w3,w2,w3,w2,w1,w2,w3,w2,w3,w2,w1,w2,w1,w0,w1,w2,w1,w2,w3,w2,w3,w2,w1,w2,w3,w2,w3]
cx = [-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1,-1, 0, 1]
cy = [-1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1,-1,-1,-1, 0, 0, 0, 1, 1, 1]
cz = [-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]
#      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
for i in range(27):
	R[i] = var(str('R[' + str(i) + ']'))
	S[i] = var(str('S[' + str(i) + ']'))
	psi_f[i]= var(str('psi_f(' + str(cx[i]) + ',' + str(cy[i]) + ',' + str(cz[i]) + ')'))
	psi_g[i]= var(str('psi_g(' + str(cx[i]) + ',' + str(cy[i]) + ',' + str(cz[i]) + ')'))
	psi_s[i]= var(str('psi_solid(' + str(cx[i]) + ',' + str(cy[i]) + ',' + str(cz[i]) + ')'))  

ueq_f = var(['ueq_f.x', 'ueq_f.y','ueq_f.z'])
ueq_g = var(['ueq_g.x', 'ueq_g.y','ueq_g.z'])
u   = var(['u.x', 'u.y', 'u.z'])
u1  = var([['uf.x', 'uf.y','uf.z'],['ug.x', 'ug.y','ug.z']])

Force = var(['Force.x', 'Force.y','Force.z'])
#endregion python preamble
?>
#define pi 3.141592653589793116

CudaDeviceFunction real_t getRhof(){
	return <?R C(sum(f)) ?> ;
}
CudaDeviceFunction real_t getRhog(){
	return <?R C(sum(g)) ?> ;
}  
CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)+sum(g)) ?> ;
}  
CudaDeviceFunction vector_t getU(){
	// Common velocity
	real_t rf = <?R C(sum(f)) ?>;
	real_t rg = <?R C(sum(g)) ?>;
	vector_t u,uf,ug;
<?python
numx = 0.0
numy = 0.0
numz = 0.0
denxyz = 0.0
for i in range(2):
	denxyz += rho[i] * om[i]
	for j in range(27):
		ind = i*27+j
		numx += Densities[ind] * cx[j] * om[i]
		numy += Densities[ind] * cy[j] * om[i]
		numz += Densities[ind] * cz[j] * om[i]

print_ccode(numx/denxyz, assign_to=u[0])
print_ccode(numy/denxyz, assign_to=u[1])
print_ccode(numz/denxyz, assign_to=u[2])
?>
	return u;
}
CudaDeviceFunction real_t EoS_CS(){ //IGNORE FOR NOW
	// TO DO: link to psi_f() function
	real_t d = <?R C(sum(f)) ?>;
	real_t p;
	real_t Tc=0.0943;
	real_t temp_bp = b*d/4.0;
	p = d*R*T*Tc*(1+temp_bp+temp_bp*temp_bp-temp_bp*temp_bp*temp_bp);
	p = p/((1-temp_bp)*(1-temp_bp)*(1-temp_bp));
	p = p - a*d*d;
	return p;
}
CudaDeviceFunction vector_t getFf(){
	vector_t Force;
	real_t R[27];//, S[27];
	Force.x = 0.0;
	Force.y = 0.0;
	Force.z = 0.0;
	//Assign stencil Values:
<?python
print_ccode(psi_f[13],assign_to=R[13])
#print_ccode(psi_s[13],assign_to=S[13])
for i in range(13):
	print_ccode(psi_g[i], assign_to=R[i])
#	print_ccode(psi_s[i], assign_to=S[i])
for i in range(14,27):
	print_ccode(psi_g[i], assign_to=R[i])
#	print_ccode(psi_s[i], assign_to=S[i])
?>
	//Calculate Forcing Terms:
<?python
F_fgx = 0
F_fgy = 0
F_fgz = 0
#F_fsx = 0
#F_fsy = 0
#F_fsz = 0
for i in range(27):
	F_fgx += w[i]*cx[i]*R[i]
	F_fgy += w[i]*cy[i]*R[i]
	F_fgz += w[i]*cz[i]*R[i]
#	F_fsx += w[i]*cx[i]*S[i]
#	F_fsy += w[i]*cy[i]*S[i]
#	F_fsz += w[i]*cz[i]*S[i]
F_fgx =-G[2] * R[13] * F_fgx
F_fgy =-G[2] * R[13] * F_fgy
F_fgz =-G[2] * R[13] * F_fgz
#F_fsx =-Gs[0]* R[13] * F_fsx
#F_fsy =-Gs[0]* R[13] * F_fsy
#F_fsz =-Gs[0]* R[13] * F_fsz
print_ccode(F_fgx , assign_to=Force[0])
print_ccode(F_fgy , assign_to=Force[1])
print_ccode(F_fgz , assign_to=Force[2])
?>
	return Force;
}
CudaDeviceFunction vector_t getFg(){
	vector_t Force;
	real_t R[27];//, S[27];
	Force.x = 0.0;
	Force.y = 0.0;
	Force.z = 0.0;
	//Assign stencil Values:
<?python
print_ccode(psi_g[13],assign_to=R[13])
#print_ccode(psi_s[13],assign_to=S[13])
for i in range(13):
	print_ccode(psi_f[i], assign_to=R[i])
#	print_ccode(psi_s[i], assign_to=S[i])
for i in range(14,27):
	print_ccode(psi_f[i], assign_to=R[i])
#	print_ccode(psi_s[i], assign_to=S[i])
?>
	//Calculate Forcing Terms:
<?python
F_fgx = 0
F_fgy = 0
F_fgz = 0
#F_fsx = 0
#F_fsy = 0
#F_fsz = 0
for i in range(27):
	F_fgx += w[i]*cx[i]*R[i]
	F_fgy += w[i]*cy[i]*R[i]
	F_fgz += w[i]*cz[i]*R[i]
#	F_fsx += w[i]*cx[i]*S[i]
#	F_fsy += w[i]*cy[i]*S[i]
#	F_fsz += w[i]*cz[i]*S[i]
F_fgx =-G[2] * R[13] * F_fgx
F_fgy =-G[2] * R[13] * F_fgy
F_fgz =-G[2] * R[13] * F_fgz
#F_fsx =-Gs[1]* R[13] * F_fsx
#F_fsy =-Gs[1]* R[13] * F_fsy
#F_fsz =-Gs[1]* R[13] * F_fsz
print_ccode(F_fgx , assign_to=Force[0])
print_ccode(F_fgy , assign_to=Force[1])
print_ccode(F_fgz , assign_to=Force[2])
?>
	return Force;
}
CudaDeviceFunction real_t getP(){
	//TO DO: Need to properly calculate this value.
		real_t rf  = <?R C(sum(f))?>;
		real_t rg  = <?R C(sum(g))?>;
		real_t rho = rf+rg;
		return rho/3.0 + G12 * psi_g * psi_f/3.0;
}

CudaDeviceFunction void CalcPsi_f(){
	// TO DO: As per Stiles and Xue (2016)
	real_t d = <?R C(sum(f)) ?> ;
	psi_f = d;
	//real_t p = EoS_CS();
	//psi_f =pow(  ( abs(2.0*(kappa*p-d/3.0) / 6.0 )), 0.5) ;
	if (NodeType & NODE_Wall) {
		psi_f = Gad2/G12;
	}
}
CudaDeviceFunction void CalcPsi_g(){
	//Assume the gas is ideal
	real_t d = <?R C(sum(g)) ?> ;
	psi_g = d;
	//psi_g = 1.0*(1.0-exp(-d/1.0)); //rho_0=1.0 as per Stiles & Xue (2016)
	if (NodeType & NODE_Wall) {
		psi_g = Gad1/G21;
	}
}

CudaDeviceFunction void SetEquilibrium_f(real_t rho, real_t Jx, real_t Jy, real_t Jz){
	if (rho > 0.0001){
<?R
	C(f,EQ$Req %*% solve(EQ$mat))
?>}
	else {
<?python
for i in range(27):
	print_ccode(0.0, assign_to=Densities[i])
?>
	}
}
CudaDeviceFunction void SetEquilibrium_g(real_t rho, real_t Jx, real_t Jy, real_t Jz){
	if (rho > 0.0001){
<?R
	C(g,EQ_g$Req %*% solve(EQ_g$mat))
?>}
	else {
<?python
for i in range(27,54):
	print_ccode(0.0, assign_to=Densities[i])
?>
	}
}

CudaDeviceFunction void Init() {

	if (NodeType & NODE_Wall)
	{
		SetEquilibrium_f(0,0,0,0);
		SetEquilibrium_g(0,0,0,0);
		//psi_solid = 1.0;
	}
	else 
	{
		//psi_solid = 0.0;
		SetEquilibrium_f(
			Density,
			Velocity_f*Density,
			0.0*Density,
			0.0*Density
		);
		SetEquilibrium_g(
			Density_dry,
			Velocity_g*Density_dry,
			0.0*Density_dry,
			0.0*Density_dry
		);
	}
}

CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
	case NODE_Solid:
	case NODE_Wall:
		BounceBack();
		break;
	case NODE_EVelocity:
		EVelocity();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
    }
    if (NodeType & NODE_BGK)
    {
		//MRT operator has not been updated to correctly include
		//multi-component force (on TO-DO list)
		CollisionBGK();
    }
}

CudaDeviceFunction void CollisionBGK()
{
	real_t uf;
	real_t rg = <?R C(sum(g)) ?>;
	real_t rf = <?R C(sum(f)) ?>;
	vector_t u_common  = getU();
	vector_t Force_f = getFf();
	vector_t Force_g = getFg();
	vector_t ueq_f;
	vector_t ueq_g;
	if (rf > 0.0001){
		ueq_f.x = u_common.x + Force_f.x/(omega * rf);
		ueq_f.y = u_common.y + Force_f.y/(omega * rf);
		ueq_f.z = u_common.z + Force_f.z/(omega * rf);}
	else {
		ueq_f.x = u_common.x;
		ueq_f.y = u_common.y;
		ueq_f.z = u_common.z;}
	if (rg > 0.0001){
		ueq_g.x = u_common.x + Force_g.x/(omega_g * rg) + GravitationX/(omega_g * rg);
		ueq_g.y = u_common.y + Force_g.y/(omega_g * rg);
		ueq_g.z = u_common.z + Force_g.z/(omega_g * rg);}
	else{
		ueq_g.x = u_common.x;
		ueq_g.y = u_common.y;
		ueq_g.z = u_common.z;}
	
<?python
for i in range(27):
	cdotu = cx[i]*ueq_f[0] + cy[i]*ueq_f[1] + cz[i]*ueq_f[2]
	umag  = ueq_f[0]*ueq_f[0] + ueq_f[1]*ueq_f[1] + ueq_f[2]*ueq_f[2]
	feq[i] = w[i]*rho[0]*(1.0 + (cdotu)*3.0 + (cdotu**2)*4.5 - 1.5*umag)
	collide = Densities[i] - om[0]*(Densities[i] - feq[i])
	print_ccode(collide, assign_to=Densities[i]) 
for i in range(27):
	cdotu = cx[i]*ueq_g[0] + cy[i]*ueq_g[1] + cz[i]*ueq_g[2]
	umag  = ueq_g[0]*ueq_g[0] + ueq_g[1]*ueq_g[1] + ueq_g[2]*ueq_g[2]
	feq[i] = w[i]*rho[1]*(1.0 + (cdotu)*3.0 + (cdotu**2)*4.5 - 1.5*umag)
	collide = Densities[i+27] - om[1]*(Densities[i+27] - feq[i])
	print_ccode(collide, assign_to=Densities[i+27]) 
?>
AddToTotalDensity1(rf);
AddToTotalDensity2(rg);
}


CudaDeviceFunction void BounceBack()
{
	<?R FullBounceBack() ?>
}

CudaDeviceFunction void EVelocity()
{
	real_t Velocity = Velocity_f;
<?R 
	ZouHe(EQ, 1, -1, "velocity",f) 
?>
	Velocity = Velocity_g;
<?R
    ZouHe(EQ_g, 1, -1,"velocity",g,predefined="true") 
?>
}

CudaDeviceFunction void WPressure()
{
	real_t Pressure = Density/3. - 1/3.;
<?R 
	ZouHe(EQ, 1, 1, "pressure",f) 
?>
	Pressure = Density_dry/3. - 1/3.;
<?R
	ZouHe(EQ_g, 1, 1, "pressure",g,predefined="true")
?>
}

CudaDeviceFunction void WVelocity()
{
	real_t Velocity = Velocity_f;
<?R 
	ZouHe(EQ, 1, 1, "velocity",f)
?>
	Velocity = Velocity_g;
<?R
	ZouHe(EQ_g, 1, 1, "velocity",g,predefined="true")
?>
}

CudaDeviceFunction void EPressure()
{
	real_t Pressure = Density/3. - 1/3.;
<?R 
	ZouHe(EQ, 1, -1, "pressure",f) 
?>
	Pressure = Density_dry/3. - 1/3.;
<?R
	ZouHe(EQ_g, 1, -1, "pressure",g,predefined="true")
?>
}

CudaDeviceFunction void CollisionMRT()
{
 
}

CudaDeviceFunction vector_t getA()
{
	vector_t A;
	A.x = 0.0;
	A.y = 0.0;
	A.z = 0.0;
	return A;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}
