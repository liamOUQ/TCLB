<?R
	source("conf.R")
        c_header();
?>
/*  Dynamics for d3q19                                         */
/*                                                             */
/*-------------------------------------------------------------*/

<?R
	source("lib/d3q19.R")

	Flow = d3q19_MRT("rho", c("Jx","Jy","Jz"), "R", group="f")

	f = Flow$f
	rho = Flow$rho
	J   = Flow$J
        Req = Flow$Req
        U   = Flow$U
        R   = Flow$R
	selR= Flow$selR
?>

CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>;
}

CudaDeviceFunction real_t getP(){
	return ((<?R C(sum(f)) ?>)-1.0)/3.0;
}

CudaDeviceFunction vector_t getU(){
	real_t d = getRho();
	vector_t u;
<?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= d;
	u.y /= d;
	u.z /= d;
	if ((NodeType & NODE_BOUNDARY) == NODE_Wall) u.x = u.y = u.z = 0;
	return u;
}

CudaDeviceFunction vector_t getNodeForce(){
	vector_t Force;
	if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
		Force.x = -2.0 * (-f14 + f13 - f12 + f11 - f10 + f9 - f8 + f7 - f2 + f1);
		Force.y = -2.0 * (-f18 + f17 - f16 + f15 - f10 - f9 + f8 + f7 - f4 + f3);
		Force.z = -2.0 * (-f18 - f17 + f16 + f15 - f14 - f13 + f12 + f11 - f6 + f5);
	}	else if ((NodeType & NODE_BOUNDARY) == NODE_IMBwall){
		real_t f[19];
		real_t rho, Jx, Jy, Jz;

		rho = f18 + f17 + f16 + f15 + f14 + f13 + f12 + f11 + f10 + f9 + f8 + f7 + f6 + f5 + f4 + f3 + f2 + f1 + f0;
		Jx = -f14 + f13 - f12 + f11 - f10 + f9 - f8 + f7 - f2 + f1;
		Jy = -f18 + f17 - f16 + f15 - f10 - f9 + f8 + f7 - f4 + f3;
		Jz = -f18 - f17 + f16 + f15 - f14 - f13 + f12 + f11 - f6 + f5;

		f[1] = 1.0* (f2 - f1 - (( -Jx + ( -Jz*Jz - Jy*Jy + Jx*Jx )/rho )*3. )/18.);
		f[2] = 1.0* (f1 - f2 - ((  Jx + ( -Jz*Jz - Jy*Jy + Jx*Jx )/rho )*3. )/18.);

		f[3] = 1.0* (f4 - f3  - (( -Jy + ( -Jz*Jz + Jy*Jy - Jx*Jx )/rho )*3. )/18.);
		f[4] = 1.0* (f3 - f4  - ((  Jy + ( -Jz*Jz + Jy*Jy - Jx*Jx )/rho )*3. )/18.);

		f[5] = 1.0* (f6 - f5  - (( -Jz + ( Jz*Jz - Jy*Jy - Jx*Jx )/rho )*3. )/18.);
		f[6] = 1.0* (f5 - f6  - ((  Jz + ( Jz*Jz - Jy*Jy - Jx*Jx )/rho )*3. )/18.);

		f[7]  = 1.0* (f10 - f7  - (( -Jy - Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.);
		f[10] = 1.0* (f7 - f10 - ((  Jy + Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.);

		f[8] = 1.0* (f9 - f8 - (( -Jy + Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.);
		f[9] = 1.0* (f8 - f9 - ((  Jy - Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.);


		f[11] = 1.0* (f14 - f11 - (( -Jz - Jx + ( Jz*Jz + ( Jx + Jz*3. )*Jx )/rho )*3. )/36.);
		f[14] = 1.0* (f11 - f14 - ((  Jz + Jx + ( Jz*Jz + ( Jx + Jz*3. )*Jx )/rho )*3. )/36.);


		f[12] = 1.0* (f13 - f12 - (( -Jz + Jx + ( Jz*Jz + ( Jx - Jz*3. )*Jx )/rho )*3. )/36.);
		f[13] = 1.0* (f12 - f13 - ((  Jz - Jx + ( Jz*Jz + ( Jx - Jz*3. )*Jx )/rho )*3. )/36.);
		

		f[15] = 1.0* (f18 - f15 - (( -Jz - Jy + ( Jz*Jz + ( Jy + Jz*3. )*Jy )/rho )*3. )/36.);
		f[18] = 1.0* (f15 - f18 - ((  Jz + Jy + ( Jz*Jz + ( Jy + Jz*3. )*Jy )/rho )*3. )/36.);


		f[16] = 1.0* (f17 - f16 - (( -Jz + Jy + ( Jz*Jz + ( Jy - Jz*3. )*Jy )/rho )*3. )/36.);
		f[17] = 1.0* (f16 - f17 - ((  Jz - Jy + ( Jz*Jz + ( Jy - Jz*3. )*Jy )/rho )*3. )/36.);

		Force.x = (-f[14] + f[13] - f[12] + f[11] - f[10] + f[9] - f[8] + f[7] - f[2] + f[1]);
		Force.y = (-f[18] + f[17] - f[16] + f[15] - f[10] - f[9] + f[8] + f[7] - f[4] + f[3]);
		Force.z = (-f[18] - f[17] + f[16] + f[15] - f[14] - f[13] + f[12] + f[11] - f[6] + f[5]);

	}	else {
		Force.x = 0.0;
		Force.y = 0.0;
		Force.z = 0.0;
	}



	return Force;
}

CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
        if ((NodeType & NODE_BOUNDARY) == NODE_Wall){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}

CudaDeviceFunction void BounceBack()
{
     real_t uf;
<?R
	uf = PV("uf")
	by(Density, Density$group, function(d) {
		i = order(d$dx,d$dy,d$dz)
		j = order(-d$dx,-d$dy,-d$dz)
		if (any(d[i,c("dx","dy","dz")]!=-d[j,c("dx","dy","dz")])) stop("Density directions are not fully symetric!");
		V = cbind(i,j);
		sel = V[,1] > V[,2]
		V = V[sel,, drop=F]
		if (nrow(V) > 0) {
		f = PV(d$name)
		apply(V,1,function(x) {
			C(uf,f[x[1]])
			C(f[x[1]],f[x[2]])
			C(f[x[2]],uf)
		})
		}
	NULL})
?>
		AddToSolidForceX( 2.0 * (-f14 + f13 - f12 + f11 - f10 + f9 - f8 + f7 - f2 + f1)    );
		AddToSolidForceY( 2.0 * (-f18 + f17 - f16 + f15 - f10 - f9 + f8 + f7 - f4 + f3)    );
		AddToSolidForceZ( 2.0 * (-f18 - f17 + f16 + f15 - f14 - f13 + f12 + f11 - f6 + f5) );

}

CudaDeviceFunction void IMBBounceBack(){
	real_t rho, Jx, Jy, Jz, tmp;

	rho = f18 + f17 + f16 + f15 + f14 + f13 + f12 + f11 + f10 + f9 + f8 + f7 + f6 + f5 + f4 + f3 + f2 + f1 + f0;
	Jx = -f14 + f13 - f12 + f11 - f10 + f9 - f8 + f7 - f2 + f1;
	Jy = -f18 + f17 - f16 + f15 - f10 - f9 + f8 + f7 - f4 + f3;
	Jz = -f18 - f17 + f16 + f15 - f14 - f13 + f12 + f11 - f6 + f5;

// IMB operator with stationary particle, so loss rho*wi from equilibrium.
/*	f0 = f0 - (( -Jz*Jz - Jy*Jy - Jx*Jx )/rho )/3.;

	tmp = f1;
	f1 = f1 + 1.0* (f2 - f1 - ((  Jx + ( -Jz*Jz - Jy*Jy + Jx*Jx )/rho )*3. )/18.);
	f2 = f2 + 1.0* (tmp- f1 - (( -Jx + ( -Jz*Jz - Jy*Jy + Jx*Jx )/rho )*3. )/18.);

	tmp = f3;
	f3 = f3 + 1.0* (f4 - f3  - ((  Jy + ( -Jz*Jz + Jy*Jy - Jx*Jx )/rho )*3. )/18.);
	f4 = f4 + 1.0* (tmp- f4  - (( -Jy + ( -Jz*Jz + Jy*Jy - Jx*Jx )/rho )*3. )/18.);

	tmp = f5;
	f5 = f5 + 1.0* (f6 - f5  - ((  Jz + ( Jz*Jz - Jy*Jy - Jx*Jx )/rho )*3. )/18.);
	f6 = f6 + 1.0* (tmp- f6  - (( -Jz + ( Jz*Jz - Jy*Jy - Jx*Jx )/rho )*3. )/18.);

	tmp = f7;
	f7  = f7 + 1.0* (f10 - f7  - ((  Jy + Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.);
	f10 = f10 + 1.0*(tmp - f10 - (( -Jy - Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.);

	tmp = f8;
	f8 = f8 + 1.0* (f9 - f8 - ((  Jy - Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.);
	f9 = f9 + 1.0* (tmp- f9 - (( -Jy + Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.);

	tmp = f11;
	f11 = f11 + 1.0* (f14 - f11 - ((  Jz + Jx + ( Jz*Jz + ( Jx + Jz*3. )*Jx )/rho )*3. )/36.);
	f14 = f14 + 1.0* (tmp - f14 - (( -Jz - Jx + ( Jz*Jz + ( Jx + Jz*3. )*Jx )/rho )*3. )/36.);

	tmp = f12;
	f12 = f12 + 1.0* (f13 - f12 - ((  Jz - Jx + ( Jz*Jz + ( Jx - Jz*3. )*Jx )/rho )*3. )/36.);
	f13 = f13 + 1.0* (tmp - f13 - (( -Jz + Jx + ( Jz*Jz + ( Jx - Jz*3. )*Jx )/rho )*3. )/36.);
	
	tmp = f15;
	f15 = f15 + 1.0* (f18 - f15 - ((  Jz + Jy + ( Jz*Jz + ( Jy + Jz*3. )*Jy )/rho )*3. )/36.);
	f18 = f18 + 1.0* (tmp - f18 - (( -Jz - Jy + ( Jz*Jz + ( Jy + Jz*3. )*Jy )/rho )*3. )/36.);

	tmp = f16;
	f16 = f16 + 1.0* (f17 - f16 - (( Jz - Jy + ( Jz*Jz + ( Jy - Jz*3. )*Jy )/rho )*3. )/36.);
	f17 = f17 + 1.0* (tmp - f17 - (( -Jz + Jy + ( Jz*Jz + ( Jy - Jz*3. )*Jy )/rho )*3. )/36.);*/

	f0 = f0 - 1.0* (( -Jz*Jz - Jy*Jy - Jx*Jx )/rho )/3.;

	tmp = f1;
	f1 = f1 + 1.0* (f2 - f1 - (( -Jx + ( -Jz*Jz - Jy*Jy + Jx*Jx )/rho )*3. )/18.);
	f2 = f2 + 1.0* (tmp- f2 - ((  Jx + ( -Jz*Jz - Jy*Jy + Jx*Jx )/rho )*3. )/18.);

	tmp = f3;
	f3 = f3 + 1.0* (f4 - f3  - (( -Jy + ( -Jz*Jz + Jy*Jy - Jx*Jx )/rho )*3. )/18.);
	f4 = f4 + 1.0* (tmp- f4  - ((  Jy + ( -Jz*Jz + Jy*Jy - Jx*Jx )/rho )*3. )/18.);

	tmp = f5;
	f5 = f5 + 1.0* (f6 - f5  - (( -Jz + ( Jz*Jz - Jy*Jy - Jx*Jx )/rho )*3. )/18.);
	f6 = f6 + 1.0* (tmp- f6  - ((  Jz + ( Jz*Jz - Jy*Jy - Jx*Jx )/rho )*3. )/18.);

	tmp = f7;
	f7  = f7 + 1.0* (f10 - f7  - (( -Jy - Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.);
	f10 = f10 + 1.0*(tmp - f10 - ((  Jy + Jx + ( Jy*Jy + ( Jx + Jy*3. )*Jx )/rho )*3. )/36.);

	tmp = f8;
	f8 = f8 + 1.0* (f9 - f8 - (( -Jy + Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.);
	f9 = f9 + 1.0* (tmp- f9 - ((  Jy - Jx + ( Jy*Jy + ( Jx - Jy*3. )*Jx )/rho )*3. )/36.);

	tmp = f11;
	f11 = f11 + 1.0* (f14 - f11 - (( -Jz - Jx + ( Jz*Jz + ( Jx + Jz*3. )*Jx )/rho )*3. )/36.);
	f14 = f14 + 1.0* (tmp - f14 - ((  Jz + Jx + ( Jz*Jz + ( Jx + Jz*3. )*Jx )/rho )*3. )/36.);

	tmp = f12;
	f12 = f12 + 1.0* (f13 - f12 - (( -Jz + Jx + ( Jz*Jz + ( Jx - Jz*3. )*Jx )/rho )*3. )/36.);
	f13 = f13 + 1.0* (tmp - f13 - ((  Jz - Jx + ( Jz*Jz + ( Jx - Jz*3. )*Jx )/rho )*3. )/36.);
	
	tmp = f15;
	f15 = f15 + 1.0* (f18 - f15 - (( -Jz - Jy + ( Jz*Jz + ( Jy + Jz*3. )*Jy )/rho )*3. )/36.);
	f18 = f18 + 1.0* (tmp - f18 - ((  Jz + Jy + ( Jz*Jz + ( Jy + Jz*3. )*Jy )/rho )*3. )/36.);

	tmp = f16;
	f16 = f16 + 1.0* (f17 - f16 - (( -Jz + Jy + ( Jz*Jz + ( Jy - Jz*3. )*Jy )/rho )*3. )/36.);
	f17 = f17 + 1.0* (tmp - f17 - ((  Jz - Jy + ( Jz*Jz + ( Jy - Jz*3. )*Jy )/rho )*3. )/36.);

	AddToSolidForceX( 2.0 * (-f14 + f13 - f12 + f11 - f10 + f9 - f8 + f7 - f2 + f1)    );
	AddToSolidForceY( 2.0 * (-f18 + f17 - f16 + f15 - f10 - f9 + f8 + f7 - f4 + f3)    );
	AddToSolidForceZ( 2.0 * (-f18 - f17 + f16 + f15 - f14 - f13 + f12 + f11 - f6 + f5) );
}


CudaDeviceFunction void EVelocity()
{

}

CudaDeviceFunction void eqWVelocity()
{
}


<?R
	X = U[,1]
	Y = U[,2]
	Z = U[,3]

        renum = c(19, 1, 2, 3, 4, 5, 6, 7, 11, 8, 12, 9, 13, 10, 14, 15, 17, 16, 18)
        I = rep(0, 19)
        I[renum] = 1:19

?>

<?R Inlet = function() { ?>
	Nxy = (<?R C(sum(f[X == 0 & Y > 0]) - sum(f[X == 0 & Y < 0])) ?>)/2.;
	Nxz = (<?R C(sum(f[X == 0 & Z > 0]) - sum(f[X == 0 & Z < 0])) ?>)/2.;

	f<?%d -1 + I[ 1] ?> = f<?%d -1 + I[ 2] ?> + rho * ux / 3.;
	f<?%d -1 + I[ 8] ?> = f<?%d -1 + I[11] ?> + rho * ux / 6. + Nxy;
	f<?%d -1 + I[ 7] ?> = f<?%d -1 + I[12] ?> + rho * ux / 6. - Nxy;
	f<?%d -1 + I[ 9] ?> = f<?%d -1 + I[14] ?> + rho * ux / 6. - Nxz;
	f<?%d -1 + I[10] ?> = f<?%d -1 + I[13] ?> + rho * ux / 6. + Nxz;

<?R } ?>

CudaDeviceFunction void WVelocity()
{
     real_t rho, Nxy, Nxz;
	real_t ux = InletVelocity;

<?R
	C(rho, sum(f[X <  0]),float=F)
	C(rho, sum(f[X == 0]) + 2 * rho, float=F)
?>
	rho = rho / (1. - ux);

<?R Inlet(); ?>
}

CudaDeviceFunction void WPressure()
{
     real_t rho, Nxy, Nxz;
	real_t ux;
	rho = InletDensity;
<?R
	ux = PV("ux")
	C(ux, sum(f[X <  0]),float=F)
	C(ux, sum(f[X == 0]) + 2 * ux, float=F)
?>
	ux = 1. - ux / rho;
<?R Inlet(); ?>
}

CudaDeviceFunction void WPressureLimited()
{
     real_t rho, Nxy, Nxz, SF, ux;
<?R
	SF = PV("SF")
	C(SF, sum(f[X <  0]),float=F)
	C(SF, sum(f[X == 0]) + 2 * SF, float=F)
?>
	rho = InletDensity;
	ux = 1. - SF / rho;
	if (ux > InletVelocity) {
		ux = InletVelocity;
		rho = SF / (1. - ux);
	}
<?R Inlet(); ?>
}



CudaDeviceFunction void EPressure()
{
     real_t rho = 1.0;
     real_t Nxy, Nxz;
     real_t ux;
<?R
	ux = PV("ux")
	C(ux, sum(f[X >  0]),float=F)
	C(ux, sum(f[X == 0]) + 2 * ux, float=F)
?>
	ux =  -1. + ux / rho;

	Nxy = (<?R C(sum(f[X == 0 & Y > 0]) - sum(f[X == 0 & Y < 0])) ?>)/2;
	Nxz = (<?R C(sum(f[X == 0 & Z > 0]) - sum(f[X == 0 & Z < 0])) ?>)/2;

	f<?%d -1 + I[ 2] ?> = f<?%d -1 + I[ 1] ?> - rho * ux / 3.0;
	f<?%d -1 + I[11] ?> = f<?%d -1 + I[ 8] ?> - rho * ux / 6.0 - Nxy;
	f<?%d -1 + I[12] ?> = f<?%d -1 + I[ 7] ?> - rho * ux / 6.0 + Nxy;
	f<?%d -1 + I[14] ?> = f<?%d -1 + I[ 9] ?> - rho * ux / 6.0 + Nxz;
	f<?%d -1 + I[13] ?> = f<?%d -1 + I[10] ?> - rho * ux / 6.0 - Nxz;


}

CudaDeviceFunction void Run() {
//	printf("Run %d %d -> (%d,%d)\n", CudaBlock.x, CudaBlock.y, X, Y);


//    AddToVOLrho(<?R C(sum(f)) ?>);

    switch (NodeType & NODE_BOUNDARY) {
	case NODE_WPressureL:
		WPressureLimited();
		break;
	case NODE_WPressure:
		WPressure();
		break;
	case NODE_WVelocity:
		WVelocity();
		break;
	case NODE_EPressure:
		EPressure();
		break;
	case NODE_Wall:
	case NODE_Solid:
		BounceBack();
        break;
    case NODE_IMBwall:
    	IMBBounceBack();
    }
    switch (NodeType & NODE_COLLISION) {
	case NODE_MRT:
		CollisionMRT();
		break;
	case NODE_BGK:
		CollisionBGK();
    }
}

CudaDeviceFunction void SetEquilibrum(real_t rho, real_t Jx, real_t Jy, real_t Jz)
{
	<?R
		C(f, Req %*% MRTMAT.inv);
	?>
}

CudaDeviceFunction void Init() {
	SetEquilibrum(1.0, InletVelocity, 0., 0.);
}

CudaDeviceFunction void CollisionMRT()
{
	real_t omT;
	real_t <?R C(R, sep=", ") ?>;
        #define S1 0.0
        #define S2 omega
        #define S3 omega
        #define S4 0.0
        #define S5 omega2
        #define S6 0.0
        #define S7 omega2
        #define S8 0.0
        #define S9 omega2
        #define S10 omega
        #define S11 omega
        #define S12 omega
        #define S13 omega
        #define S14 omega
        #define S15 omega
        #define S16 omega
        #define S17 omega2
        #define S18 omega2
        #define S19 omega2
        real_t gamma1 = 1 - omega;
        real_t gamma2 = 1 - 8.0 * ( 2.0 - omega )/( 8.0 - omega );
<?R
	S = PV("S",1:19);
	S[c(1,4,6,8)] = 0;
	S[c(2,3,10:16)] = PV("gamma1");
	S[c(5,7,9,17:19)] = PV("gamma2");
	C(R, f %*% MRTMAT);
	C(R[selR], (S*(R-Req))[selR]);
?>
    Jx += rho*ForceX;
    Jy += rho*ForceY;
    Jz += rho*ForceZ;
<?R
	C(R[selR], (R + Req)[selR]);
	# nearly ortogonal MRT matrix
        Mw = colSums(MRTMAT**2)
	C(R,  Mw, eq="/=")
	C( f, R %*% t(MRTMAT) , float=F);
?>
    real_t ux,uy,uz;
    ux = Jx / rho;
    uy = Jy / rho;
    uz = Jz / rho;
    switch (NodeType & NODE_ADDITIONALS) {
    <?R for (plane in c("XY","XZ","YZ")) { ?>
    case NODE_<?%s plane ?>slice:
     AddTo<?%s plane ?>vx(ux);
     AddTo<?%s plane ?>vy(uy);
     AddTo<?%s plane ?>vz(uz);
     AddTo<?%s plane ?>rho(rho);
     AddTo<?%s plane ?>area(1);
     break;
    <?R } ?>
    }
    AddToVOLvx(ux);
    AddToVOLvy(uy);
    AddToVOLvz(uz);
    AddToVOLpx(Jx);
    AddToVOLpy(Jy);
    AddToVOLpz(Jz);
    AddToVOLrho(rho);
    AddToVOLvolume(1);
    AddToMaxV(sqrt(ux*ux+uy*uy+uz*uz));
}

CudaDeviceFunction void CollisionBGK()
{
	real_t omT;
	real_t <?R C(R, sep=", ") ?>;
        #define S1 0.0
        #define S2 omega
        #define S3 omega
        #define S4 0.0
        #define S5 omega2
        #define S6 0.0
        #define S7 omega2
        #define S8 0.0
        #define S9 omega2
        #define S10 omega
        #define S11 omega
        #define S12 omega
        #define S13 omega
        #define S14 omega
        #define S15 omega
        #define S16 omega
        #define S17 omega2
        #define S18 omega2
        #define S19 omega2
        real_t gamma1 = 1 - omega;
<?R
	S = PV("S",1:19);
	S[c(1,4,6,8)] = PV("gamma1");
	S[c(2,3,10:16)] = PV("gamma1");
	S[c(5,7,9,17:19)] = PV("gamma1");
	C(R, f %*% MRTMAT);
	C(R[selR], (S*(R-Req))[selR]);
?>
    Jx += rho*ForceX;
    Jy += rho*ForceY;
    Jz += rho*ForceZ;
<?R
	C(R[selR], (R + Req)[selR]);
	# nearly ortogonal MRT matrix
        Mw = colSums(MRTMAT**2)
	C(R,  Mw, eq="/=")
	C( f, R %*% t(MRTMAT) , float=F);
?>
    real_t ux,uy,uz;
    ux = Jx / rho;
    uy = Jy / rho;
    uz = Jz / rho;
    switch (NodeType & NODE_ADDITIONALS) {
    <?R for (plane in c("XY","XZ","YZ")) { ?>
    case NODE_<?%s plane ?>slice:
     AddTo<?%s plane ?>vx(ux);
     AddTo<?%s plane ?>vy(uy);
     AddTo<?%s plane ?>vz(uz);
     AddTo<?%s plane ?>rho(rho);
     AddTo<?%s plane ?>area(1);
     break;
    <?R } ?>
    }
    AddToVOLvx(ux);
    AddToVOLvy(uy);
    AddToVOLvz(uz);
    AddToVOLpx(Jx);
    AddToVOLpy(Jy);
    AddToVOLpz(Jz);
    AddToVOLrho(rho);
    AddToVOLvolume(1);
    AddToMaxV(sqrt(ux*ux+uy*uy+uz*uz));
}
