// 04/02/2017 - Model Developed: A. Fakhari, T. Mitchell
// """" An improved phase-field lattice Boltzmann model
//		for immiscible fluids at high density ratios """"
//
// Maintainer: Travis-Mitchell @TravisMitchell

// Code updates:
//		01/04/2017: Development starts...
//			    Plan is d3q27 for hydrodynamics
//			    and d3q15 for interface dynamics
//		08/04/2017: Development status update ...
//			    Code builds and runs stable for density
//			    ratio up to 100, but layered Poiseuille
//			    flow does not appear symmetric,#DebugFunTimes

<?R
    source("conf.R")
    c_header();

    g=PV(DensityAll$name[DensityAll$group=="g"])

# Extracting velocity set
    U = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy","dz")])
    u = PV(c("U","V","W"))
?>

//	EXPORTABLE QUANTITIES:
/*CudaDeviceFunction real_t getRho(){
	real_t rho;
	rho = Density_l + (Density_h-Density_l) * (PhaseF(0,0,0) - PhaseField_l)/(PhaseField_h - PhaseField_l);
	return rho;
}*/
CudaDeviceFunction real_t getPhaseField(){
	return PhaseF(0,0,0);
}
CudaDeviceFunction vector_t getU(){
	vector_t u;
	u.x = U;
	u.y = V;
	u.z = W;
	return u;
}
CudaDeviceFunction real_t getP(){
	real_t   p = <?R C(sum(g)) ?>;
	return p;
}

// 	HELPER FUNCTIONS:
CudaDeviceFunction vector_t calcGradPhi(){
	vector_t gradPhi = {0.0,0.0,0.0};
	gradPhi.x = 16.00 * (PhaseF(1,0,0) - PhaseF(-1,0,0))
		  + PhaseF(1,1,1) - PhaseF(-1,1,1) + PhaseF(1,-1,1) - PhaseF(-1,-1,1)
		  + PhaseF(1,1,-1)- PhaseF(-1,1,-1)+ PhaseF(1,-1,-1)- PhaseF(-1,-1,-1)
		  +  4.00 * (PhaseF(1,1,0) - PhaseF(-1,1,0) + PhaseF(1,-1,0) - PhaseF(-1,-1,0)
			  +  PhaseF(1,0,1) - PhaseF(-1,0,1) + PhaseF(1,0,-1) - PhaseF(-1,0,-1));
	gradPhi.y = 16.00 * (PhaseF(0,1,0) - PhaseF(0,-1,0))
		  + PhaseF(1,1,1) + PhaseF(-1,1,1) - PhaseF(1,-1,1) - PhaseF(-1,-1,1)
		  + PhaseF(1,1,-1)+ PhaseF(-1,1,-1)- PhaseF(1,-1,-1)- PhaseF(-1,-1,-1)
		  +  4.00 * (PhaseF(1,1,0) + PhaseF(-1,1,0) - PhaseF(1,-1,0) - PhaseF(-1,-1,0)
		          +  PhaseF(0,1,1) - PhaseF(0,-1,1) + PhaseF(0,1,-1) - PhaseF(0,-1,-1));
	gradPhi.z = 16.00 * (PhaseF(0,0,1) - PhaseF(0,0,-1))
		  + PhaseF(1,1,1) + PhaseF(-1,1,1) + PhaseF(1,-1,1) + PhaseF(-1,-1,1)
		  - PhaseF(1,1,-1)- PhaseF(-1,1,-1)- PhaseF(1,-1,-1)- PhaseF(-1,-1,-1)
		  +  4.00 * (PhaseF(1,0,1) + PhaseF(-1,0,1) - PhaseF(1,0,-1) - PhaseF(-1,0,-1)
		          +  PhaseF(0,1,1) + PhaseF(0,-1,1) - PhaseF(0,1,-1) - PhaseF(0,-1,-1));

	gradPhi.x /= 72.0;
	gradPhi.y /= 72.0;
	gradPhi.z /= 72.0;
	return gradPhi;
}

CudaDeviceFunction void calcPhaseF(){
	PhaseF = h0+h1+h2+h3+h4+h5+h6+h7+h8+
		 h9+h10+h11+h12+h13+h14;
}

CudaDeviceFunction real_t calcMu(real_t C){
	real_t pfavg, lpPhi, mu, phi[27];

	pfavg = 0.5*(PhaseField_l+PhaseField_h);

	lpPhi = 16.0 *((PhaseF(1,0,0)) + (PhaseF(-1,0,0))
        	     + (PhaseF(0,1,0)) + (PhaseF(0,-1,0))
        	     + (PhaseF(0,0,1)) + (PhaseF(0,0,-1)))
       	       + 1.0 *((PhaseF(1,1,1)) + (PhaseF(-1,1,1))
       		     + (PhaseF(1,-1,1))+ (PhaseF(-1,-1,1))
             	     + (PhaseF(1,1,-1))+ (PhaseF(-1,1,-1))
                     + (PhaseF(1,-1,-1))+(PhaseF(-1,-1,-1)))
       	       + 4.0 *((PhaseF(1,1,0)) + (PhaseF(-1,1,0))
	     	     + (PhaseF(1,-1,0))+ (PhaseF(-1,-1,0))
	             + (PhaseF(1,0,1)) + (PhaseF(-1,0,1))
	             + (PhaseF(1,0,-1))+ (PhaseF(-1,0,-1))
	             + (PhaseF(0,1,1)) + (PhaseF(0,-1,1))
	             + (PhaseF(0,1,-1))+ (PhaseF(0,-1,-1)))
	       - 152.0 * PhaseF(0,0,0);

	lpPhi /= 36.0;

	mu = 4.0*(12.0*sigma/Width)*(C-PhaseField_l)*(C-PhaseField_h)*(C-pfavg)
	       - (1.5 *sigma*Width) * lpPhi;

	return mu;
}

CudaDeviceFunction real_t calcGamma(int i, real_t u, real_t v, real_t w, real_t u2mag){
	real_t gamma, tmp;
	tmp = (d3q27_ex[i]*u+d3q27_ey[i]*v+d3q27_ez[i]*w);

	gamma = wg[i] * (1 + 3.0*(tmp) + 4.5*(tmp*tmp) - 1.5*(u2mag)) ;
	return gamma;
}

CudaDeviceFunction real_t calcF_phi(int i, real_t tmp1, real_t nx, real_t ny, real_t nz){
	real_t f_phi;

	f_phi = wh[i] * tmp1 * (d3q27_ex[i]*nx + d3q27_ey[i]*ny + d3q27_ez[i]*nz);
	return f_phi;
}

//	INITIALISATION:
CudaDeviceFunction void Init() {
	PhaseF = PhaseField;
}

CudaDeviceFunction void Init_distributions(){
// Find Gradients and normals:
	int i;
	real_t C = PhaseF(0,0,0);
	real_t C0 = 0.5*(PhaseField_h - PhaseField_l);
	vector_t gradPhi = calcGradPhi();
	real_t nx, ny, nz, magnPhi;
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z + 1e-32);
	nx = gradPhi.x/magnPhi;
	ny = gradPhi.y/magnPhi;
	nz = gradPhi.z/magnPhi;
// Define Equilibrium, then initialise all da things
	U = VelocityX;	V = VelocityY;	W = VelocityZ;
	real_t mag = U*U + V*V + W*W;
	real_t Gamma[27];
// ##### heq
	real_t F_phi[15], tmp1;
	tmp1 = (1.0 - 4.0*(C - C0)*(C - C0))/Width;
	for (i=0; i< 27; i++){
		Gamma[i] = calcGamma(i, U, V, W, mag);
		if (i < 15) F_phi[i] = calcF_phi(i, tmp1, nx, ny, nz);
	}
        h0 = 0.75 * C * Gamma[0] - 0.5*F_phi[0]; //Constant to fix weights for d3q15
        h1 = 1.50 * C * Gamma[1] - 0.5*F_phi[1];
        h2 = 1.50 * C * Gamma[2] - 0.5*F_phi[2];
        h3 = 1.50 * C * Gamma[3] - 0.5*F_phi[3];
        h4 = 1.50 * C * Gamma[4] - 0.5*F_phi[4];
        h5 = 1.50 * C * Gamma[5] - 0.5*F_phi[5];
        h6 = 1.50 * C * Gamma[6] - 0.5*F_phi[6];
        h7 = 3.00 * C * Gamma[7] - 0.5*F_phi[7];
        h8 = 3.00 * C * Gamma[8] - 0.5*F_phi[8];
        h9 = 3.00 * C * Gamma[9] - 0.5*F_phi[9];
        h10 = 3.00 * C * Gamma[10] - 0.5*F_phi[10];
        h11 = 3.00 * C * Gamma[11] - 0.5*F_phi[11];
        h12 = 3.00 * C * Gamma[12] - 0.5*F_phi[12];
        h13 = 3.00 * C * Gamma[13] - 0.5*F_phi[13];
        h14 = 3.00 * C * Gamma[14] - 0.5*F_phi[14];

// ##### geq
        g0 =  Gamma[0] - wg[0];
        g1 =  Gamma[1] - wg[1];
        g2 =  Gamma[2] - wg[2];
        g3 =  Gamma[3] - wg[3];
        g4 =  Gamma[4] - wg[4];
        g5 =  Gamma[5] - wg[5];
        g6 =  Gamma[6] - wg[6];
        g7 =  Gamma[7] - wg[7];
        g8 =  Gamma[8] - wg[8];
        g9 =  Gamma[9] - wg[9];
        g10 =  Gamma[10] - wg[10];
        g11 =  Gamma[11] - wg[11];
        g12 =  Gamma[12] - wg[12];
        g13 =  Gamma[13] - wg[13];
        g14 =  Gamma[14] - wg[14];
        g15 =  Gamma[15] - wg[15];
        g16 =  Gamma[16] - wg[16];
        g17 =  Gamma[17] - wg[17];
        g18 =  Gamma[18] - wg[18];
        g19 =  Gamma[19] - wg[19];
        g20 =  Gamma[20] - wg[20];
        g21 =  Gamma[21] - wg[21];
        g22 =  Gamma[22] - wg[22];
        g23 =  Gamma[23] - wg[23];
        g24 =  Gamma[24] - wg[24];
        g25 =  Gamma[25] - wg[25];
        g26 =  Gamma[26] - wg[26];
}

//	ITERATION:
CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
		case NODE_Solid:
		case NODE_Wall:
			BounceBack();
			break;
    }
    if (NodeType & NODE_MRT)
    {
		//CollisionMRT();
		//CollisionMRT_SRTstress();
    } else if (NodeType & NODE_BGK) {
		CollisionBGK();
	}
}

CudaDeviceFunction void CollisionBGK(){
	int i;
	real_t C = PhaseF(0,0,0), mu;
	real_t tau, DynVisc, rho, p;			// Macroscopic Properties
	vector_t gradPhi;				// Phase field gradients
	real_t nx, ny, nz, magnPhi;			// Normals
	real_t Gamma[27], geq[27], mag;			// equilibrium, pressure equilibrium, velocity magnitude
	real_t F_pressure[3], F_body[3], F_mu[3], F_total[3]; // Forces
	real_t tmp1, stress[6]={0.0,0.0,0.0,0.0,0.0,0.0};     // Stress tensor calculation
	real_t F_phi[15], heq[15];			// Phase field collision terms
	real_t F_i[27];					// Momentum distribution forcing term

// Find Macroscopic Details
	mu = calcMu( C );
	rho = Density_l + (C - PhaseField_l)*(Density_h - Density_l)/(PhaseField_h - PhaseField_l);
	p = <?R C(sum(g)) ?>;

// Update tau:
	if ( C < PhaseField_l){
		tau = tau_l + 0.5;
	} else if (C > PhaseField_h) {
		tau = tau_h + 0.5;
	} else {
	// Inverse update:
		//tau = (C - PhaseField_l)/(PhaseField_h - PhaseField_l) * (1.0/tau_h - 1.0/tau_l) + 1.0/tau_l;
		//tau = 1.0/tau + 0.5;
	// Linear update:
		tau = 0.5 + tau_l + (C-PhaseField_l)*(tau_h - tau_l)/(PhaseField_h - PhaseField_l);
	// Viscosity update:
		//DynVisc = Density_l*Viscosity_l + C * (Density_h*Viscosity_h - Density_l*Viscosity_l);
		//tau = 3.0 * DynVisc / rho + 0.5;
	}

// GRADIENTS AND NORMALS
	gradPhi = calcGradPhi();
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z + 1e-32);
	nx = gradPhi.x/magnPhi;
	ny = gradPhi.y/magnPhi;
	nz = gradPhi.z/magnPhi;

// GAMMA AND EQUILIBRIUM
	mag = U*U + V*V + W*W;
	for (i=0; i< 27; i++){
		Gamma[i] = calcGamma(i, U, V, W, mag);
		geq[i] = wg[i]*p + Gamma[i] - wg[i];
	}

	// CALCULATE FORCES:
	F_pressure[0] = (-1.0/3.0) * p * (Density_h-Density_l) * gradPhi.x;
	F_pressure[1] = (-1.0/3.0) * p * (Density_h-Density_l) * gradPhi.y;
	F_pressure[2] = (-1.0/3.0) * p * (Density_h-Density_l) * gradPhi.z;
	F_body[0] = (rho-Density_h)*BuoyancyX + rho*GravitationX;
	F_body[1] = (rho-Density_h)*BuoyancyY + rho*GravitationY;
	F_body[2] = (rho-Density_h)*BuoyancyZ + rho*GravitationZ;

        geq[0] = g0 - geq[0]; //gi^neq
        geq[1] = g1 - geq[1];
        geq[2] = g2 - geq[2];
        geq[3] = g3 - geq[3];
        geq[4] = g4 - geq[4];
        geq[5] = g5 - geq[5];
        geq[6] = g6 - geq[6];
        geq[7] = g7 - geq[7];
        geq[8] = g8 - geq[8];
        geq[9] = g9 - geq[9];
        geq[10] = g10 - geq[10];
        geq[11] = g11 - geq[11];
        geq[12] = g12 - geq[12];
        geq[13] = g13 - geq[13];
        geq[14] = g14 - geq[14];
        geq[15] = g15 - geq[15];
        geq[16] = g16 - geq[16];
        geq[17] = g17 - geq[17];
        geq[18] = g18 - geq[18];
        geq[19] = g19 - geq[19];
        geq[20] = g20 - geq[20];
        geq[21] = g21 - geq[21];
        geq[22] = g22 - geq[22];
        geq[23] = g23 - geq[23];
        geq[24] = g24 - geq[24];
        geq[25] = g25 - geq[25];
        geq[26] = g26 - geq[26];
		// Stress/strain Tensor
	for (i=0; i< 27; i++){
		stress[0] += geq[i]*d3q27_ex[i]*d3q27_ex[i];
		stress[1] += geq[i]*d3q27_ex[i]*d3q27_ey[i];
		stress[2] += geq[i]*d3q27_ex[i]*d3q27_ez[i];
		stress[3] += geq[i]*d3q27_ey[i]*d3q27_ey[i];
		stress[4] += geq[i]*d3q27_ey[i]*d3q27_ez[i];
		stress[5] += geq[i]*d3q27_ez[i]*d3q27_ez[i];
	}

	F_mu[0] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y + stress[2]*gradPhi.z);
	F_mu[1] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[1]*gradPhi.x + stress[3]*gradPhi.y + stress[4]*gradPhi.z);
	F_mu[2] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[2]*gradPhi.x + stress[4]*gradPhi.y + stress[5]*gradPhi.z);
	F_total[0] = mu*gradPhi.x + F_pressure[0] + F_body[0] + F_mu[0];
	F_total[1] = mu*gradPhi.y + F_pressure[1] + F_body[1] + F_mu[1];
	F_total[2] = mu*gradPhi.z + F_pressure[2] + F_body[2] + F_mu[2];

<?R C( u, g %*% U) ?>
	U = U + (0.5*F_total[0])/rho;
	V = V + (0.5*F_total[1])/rho;
	W = W + (0.5*F_total[2])/rho;

// RECALCULATE GAMMA
	mag = U*U + V*V + W*W;
	for (i=0; i< 27; i++){
		Gamma[i] = calcGamma(i, U, V, W, mag);
		geq[i] = wg[i]*p + Gamma[i] - wg[i];
	}
	for (i=0;i<6;i++) {
		stress[i] = 0.0;
	}
        geq[0] = g0 - geq[0]; //gi^neq
        geq[1] = g1 - geq[1];
        geq[2] = g2 - geq[2];
        geq[3] = g3 - geq[3];
        geq[4] = g4 - geq[4];
        geq[5] = g5 - geq[5];
        geq[6] = g6 - geq[6];
        geq[7] = g7 - geq[7];
        geq[8] = g8 - geq[8];
        geq[9] = g9 - geq[9];
        geq[10] = g10 - geq[10];
        geq[11] = g11 - geq[11];
        geq[12] = g12 - geq[12];
        geq[13] = g13 - geq[13];
        geq[14] = g14 - geq[14];
        geq[15] = g15 - geq[15];
        geq[16] = g16 - geq[16];
        geq[17] = g17 - geq[17];
        geq[18] = g18 - geq[18];
        geq[19] = g19 - geq[19];
        geq[20] = g20 - geq[20];
        geq[21] = g21 - geq[21];
        geq[22] = g22 - geq[22];
        geq[23] = g23 - geq[23];
        geq[24] = g24 - geq[24];
        geq[25] = g25 - geq[25];
        geq[26] = g26 - geq[26];
	for (i=0; i< 27; i++){
		stress[0] += geq[i]*d3q27_ex[i]*d3q27_ex[i];
		stress[1] += geq[i]*d3q27_ex[i]*d3q27_ey[i];
		stress[2] += geq[i]*d3q27_ex[i]*d3q27_ez[i];
		stress[3] += geq[i]*d3q27_ey[i]*d3q27_ey[i];
		stress[4] += geq[i]*d3q27_ey[i]*d3q27_ez[i];
		stress[5] += geq[i]*d3q27_ez[i]*d3q27_ez[i];
	}

	F_mu[0] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y + stress[2]*gradPhi.z);
	F_mu[1] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[1]*gradPhi.x + stress[3]*gradPhi.y + stress[4]*gradPhi.z);
	F_mu[2] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[2]*gradPhi.x + stress[4]*gradPhi.y + stress[5]*gradPhi.z);
	F_total[0] = mu*gradPhi.x + F_pressure[0] + F_body[0] + F_mu[0];
	F_total[1] = mu*gradPhi.y + F_pressure[1] + F_body[1] + F_mu[1];
	F_total[2] = mu*gradPhi.z + F_pressure[2] + F_body[2] + F_mu[2];

// PHASE FIELD POPULATION UPDATE:
	tmp1 = (1.0 - 4.0*(C - 0.5)*(C - 0.5))/Width;
	for (i=0; i< 15; i++){
		F_phi[i] = calcF_phi(i, tmp1, nx, ny, nz); 		// Forcing Terms
		heq[i] = C * Gamma[i];      	// heq
	}
        h0 = h0 - omega_phi * (h0 - 0.75 * heq[0] + 0.5*F_phi[0]) + F_phi[0];
        h1 = h1 - omega_phi * (h1 - 1.50 * heq[1] + 0.5*F_phi[1]) + F_phi[1];
        h2 = h2 - omega_phi * (h2 - 1.50 * heq[2] + 0.5*F_phi[2]) + F_phi[2];
        h3 = h3 - omega_phi * (h3 - 1.50 * heq[3] + 0.5*F_phi[3]) + F_phi[3];
        h4 = h4 - omega_phi * (h4 - 1.50 * heq[4] + 0.5*F_phi[4]) + F_phi[4];
        h5 = h5 - omega_phi * (h5 - 1.50 * heq[5] + 0.5*F_phi[5]) + F_phi[5];
        h6 = h6 - omega_phi * (h6 - 1.50 * heq[6] + 0.5*F_phi[6]) + F_phi[6];
        h7 = h7 - omega_phi * (h7 - 3.00 * heq[7] + 0.5*F_phi[7]) + F_phi[7];
        h8 = h8 - omega_phi * (h8 - 3.00 * heq[8] + 0.5*F_phi[8]) + F_phi[8];
        h9 = h9 - omega_phi * (h9 - 3.00 * heq[9] + 0.5*F_phi[9]) + F_phi[9];
        h10 = h10 - omega_phi * (h10 - 3.00 * heq[10] + 0.5*F_phi[10]) + F_phi[10];
        h11 = h11 - omega_phi * (h11 - 3.00 * heq[11] + 0.5*F_phi[11]) + F_phi[11];
        h12 = h12 - omega_phi * (h12 - 3.00 * heq[12] + 0.5*F_phi[12]) + F_phi[12];
        h13 = h13 - omega_phi * (h13 - 3.00 * heq[13] + 0.5*F_phi[13]) + F_phi[13];
        h14 = h14 - omega_phi * (h14 - 3.00 * heq[14] + 0.5*F_phi[14]) + F_phi[14];
// PRESSURE EVOLUTION UPDATE:
	for (i=0; i< 27; i++) {
		F_i[i] = 3.0*wg[i] * (F_total[0]*d3q27_ex[i] + F_total[1]*d3q27_ey[i] + F_total[2]*d3q27_ez[i])/rho;
	}
        g0 = g0 - (geq[0]+0.5*F_i[0])/tau + F_i[0];
        g1 = g1 - (geq[1]+0.5*F_i[1])/tau + F_i[1];
        g2 = g2 - (geq[2]+0.5*F_i[2])/tau + F_i[2];
        g3 = g3 - (geq[3]+0.5*F_i[3])/tau + F_i[3];
        g4 = g4 - (geq[4]+0.5*F_i[4])/tau + F_i[4];
        g5 = g5 - (geq[5]+0.5*F_i[5])/tau + F_i[5];
        g6 = g6 - (geq[6]+0.5*F_i[6])/tau + F_i[6];
        g7 = g7 - (geq[7]+0.5*F_i[7])/tau + F_i[7];
        g8 = g8 - (geq[8]+0.5*F_i[8])/tau + F_i[8];
        g9 = g9 - (geq[9]+0.5*F_i[9])/tau + F_i[9];
        g10 = g10 - (geq[10]+0.5*F_i[10])/tau + F_i[10];
        g11 = g11 - (geq[11]+0.5*F_i[11])/tau + F_i[11];
        g12 = g12 - (geq[12]+0.5*F_i[12])/tau + F_i[12];
        g13 = g13 - (geq[13]+0.5*F_i[13])/tau + F_i[13];
        g14 = g14 - (geq[14]+0.5*F_i[14])/tau + F_i[14];
        g15 = g15 - (geq[15]+0.5*F_i[15])/tau + F_i[15];
        g16 = g16 - (geq[16]+0.5*F_i[16])/tau + F_i[16];
        g17 = g17 - (geq[17]+0.5*F_i[17])/tau + F_i[17];
        g18 = g18 - (geq[18]+0.5*F_i[18])/tau + F_i[18];
        g19 = g19 - (geq[19]+0.5*F_i[19])/tau + F_i[19];
        g20 = g20 - (geq[20]+0.5*F_i[20])/tau + F_i[20];
        g21 = g21 - (geq[21]+0.5*F_i[21])/tau + F_i[21];
        g22 = g22 - (geq[22]+0.5*F_i[22])/tau + F_i[22];
        g23 = g23 - (geq[23]+0.5*F_i[23])/tau + F_i[23];
        g24 = g24 - (geq[24]+0.5*F_i[24])/tau + F_i[24];
        g25 = g25 - (geq[25]+0.5*F_i[25])/tau + F_i[25];
        g26 = g26 - (geq[26]+0.5*F_i[26])/tau + F_i[26];
}

//	BOUNDARY CONDITIONS:
CudaDeviceFunction void BounceBack()
{
	real_t tmp;
        tmp = g0; g0 = g0;
        tmp = g1; g1 = g2;
        tmp = g2; g2 = g1;
        tmp = g3; g3 = g4;
        tmp = g4; g4 = g3;
        tmp = g5; g5 = g6;
        tmp = g6; g6 = g5;
        tmp = g7; g7 = g14;
        tmp = g8; g8 = g13;
        tmp = g9; g9 = g12;
        tmp = g10; g10 = g11;
        tmp = g11; g11 = g10;
        tmp = g12; g12 = g9;
        tmp = g13; g13 = g8;
        tmp = g14; g14 = g7;
        tmp = g15; g15 = g18;
        tmp = g16; g16 = g17;
        tmp = g17; g17 = g16;
        tmp = g18; g18 = g15;
        tmp = g19; g19 = g22;
        tmp = g20; g20 = g21;
        tmp = g21; g21 = g20;
        tmp = g22; g22 = g19;
        tmp = g23; g23 = g26;
        tmp = g24; g24 = g25;
        tmp = g25; g25 = g24;
        tmp = g26; g26 = g23;

        tmp = h0; h0 = h0;
        tmp = h1; h1 = h2;
        tmp = h2; h2 = h1;
        tmp = h3; h3 = h4;
        tmp = h4; h4 = h3;
        tmp = h5; h5 = h6;
        tmp = h6; h6 = h5;
        tmp = h7; h7 = h14;
        tmp = h8; h8 = h13;
        tmp = h9; h9 = h12;
        tmp = h10; h10 = h11;
        tmp = h11; h11 = h10;
        tmp = h12; h12 = h9;
        tmp = h13; h13 = h8;
        tmp = h14; h14 = h7;
}

CudaDeviceFunction vector_t getA(){
	vector_t ret;
	return ret;
}
CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}
