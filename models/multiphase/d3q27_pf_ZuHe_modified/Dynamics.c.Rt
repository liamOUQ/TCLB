// 04/02/2017 - Model Developed: A. Fakhari, T. Mitchell
// """" An improved phase-field lattice Boltzmann model
//		for immiscible fluids at high density ratios """"
//
// Maintainer: Travis-Mitchell @TravisMitchell

// Code updates:
//		01/04/2017: Development starts...
//			    Plan is d3q27 for hydrodynamics
//			    and d3q15 for interface dynamics

<?R
    source("conf.R")
    c_header();

    g=PV(DensityAll$name[DensityAll$group=="g"])

# Extracting velocity set
    U = as.matrix(DensityAll[DensityAll$group=="g",c("dx","dy","dz")])
    u = PV(c("U","V","W"))
?>
/*CudaConstantMemory real_t const wg[27] = {8./27.,
				      2./27., 2./27., 2./27., 2./27., 2./27., 2./27.,
                                      1./216., 1./216., 1./216., 1./216.,
				      1./216., 1./216., 1./216., 1./216.,
				      1./54.,  1./54.,  1./54.,  1./54.,
				      1./54.,  1./54.,  1./54.,  1./54.,
				      1./54.,  1./54.,  1./54.,  1./54. };

CudaConstantMemory real_t const wh[15] = {2./9.,
 		       		          1./9., 1./9., 1./9., 1./9., 1./9., 1./9.,
					  1./72.,1./72.,1./72.,1./72.,1./72.,1./72.,1./72.,1./72.};

CudaConstantMemory real_t const d3q27_ex[27] = {0, 1,-1, 0, 0, 0, 0, 1,-1, 1,-1, 1,-1, 1,-1, 1,-1, 1,-1, 1,-1, 1,-1, 0, 0, 0, 0};
CudaConstantMemory real_t const d3q27_ey[27] = {0, 0, 0, 1,-1, 0, 0, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1,-1, 0, 0, 0, 0, 1,-1, 1,-1};
CudaConstantMemory real_t const d3q27_ez[27] = {0, 0, 0, 0, 0, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1, 0, 0, 0, 0, 1, 1,-1,-1, 1, 1,-1,-1};
*/
//CudaConstantMemory real_t const d3q15_ex = {0, 1,-1, 0, 0, 0, 0, 1,-1, 1,-1, 1,-1, 1,-1};
//CudaConstantMemory real_t const d3q15_ey = {0, 0, 0, 1,-1, 0, 0, 1, 1,-1,-1, 1, 1,-1,-1};
//CudaConstantMemory real_t const d3q15_ez = {0, 0, 0, 0, 0, 1,-1, 1, 1, 1, 1,-1,-1,-1,-1};

//	EXPORTABLE QUANTITIES:
/*CudaDeviceFunction real_t getRho(){
	real_t rho;
	rho = Density_l + (Density_h-Density_l) * (PhaseF(0,0,0) - PhaseField_l)/(PhaseField_h - PhaseField_l);
	return rho;
}*/
CudaDeviceFunction real_t getPhaseField(){
	return PhaseF(0,0,0);
}
CudaDeviceFunction vector_t getU(){
	vector_t u;
	u.x = U;
	u.y = V;
	u.z = W;
	return u;
}
CudaDeviceFunction real_t getP(){
	real_t   p = <?R C(sum(g)) ?>;
	return p;
}

// 	HELPER FUNCTIONS:
CudaDeviceFunction vector_t calcGradPhi(){
	vector_t gradPhi = {0.0,0.0,0.0};
	real_t phi[27];

        phi[0]=PhaseF(0,0,0);
        phi[1]=PhaseF(1,0,0);
        phi[2]=PhaseF(-1,0,0);
        phi[3]=PhaseF(0,1,0);
        phi[4]=PhaseF(0,-1,0);
        phi[5]=PhaseF(0,0,1);
        phi[6]=PhaseF(0,0,-1);
        phi[7]=PhaseF(1,1,1);
        phi[8]=PhaseF(-1,1,1);
        phi[9]=PhaseF(1,-1,1);
        phi[10]=PhaseF(-1,-1,1);
        phi[11]=PhaseF(1,1,-1);
        phi[12]=PhaseF(-1,1,-1);
        phi[13]=PhaseF(1,-1,-1);
        phi[14]=PhaseF(-1,-1,-1);
        phi[15]=PhaseF(1,1,0);
        phi[16]=PhaseF(-1,1,0);
        phi[17]=PhaseF(1,-1,0);
        phi[18]=PhaseF(-1,-1,0);
        phi[19]=PhaseF(1,0,1);
        phi[20]=PhaseF(-1,0,1);
        phi[21]=PhaseF(1,0,-1);
        phi[22]=PhaseF(-1,0,-1);
        phi[23]=PhaseF(0,1,1);
        phi[24]=PhaseF(0,-1,1);
        phi[25]=PhaseF(0,1,-1);
        phi[26]=PhaseF(0,-1,-1);

	for (int i=0; i<27; i++) {
		gradPhi.x += wg[i]*d3q27_ex[i]*phi[i];
		gradPhi.y += wg[i]*d3q27_ey[i]*phi[i];
		gradPhi.z += wg[i]*d3q27_ez[i]*phi[i];
	}
	gradPhi.x *= 3.0;
	gradPhi.y *= 3.0;
	gradPhi.z *= 3.0;

	return gradPhi;
}

CudaDeviceFunction void calcPhaseF(){
	PhaseF = h0+h1+h2+h3+h4+h5+h6+h7+h8+
		 h9+h10+h11+h12+h13+h14;
}

CudaDeviceFunction real_t calcMu(real_t C){
	real_t pfavg, lpPhi, mu, phi[27];

	pfavg = 0.5*(PhaseField_l+PhaseField_h);

        phi[0]=PhaseF(0,0,0);
        phi[1]=PhaseF(1,0,0);
        phi[2]=PhaseF(-1,0,0);
        phi[3]=PhaseF(0,1,0);
        phi[4]=PhaseF(0,-1,0);
        phi[5]=PhaseF(0,0,1);
        phi[6]=PhaseF(0,0,-1);
        phi[7]=PhaseF(1,1,1);
        phi[8]=PhaseF(-1,1,1);
        phi[9]=PhaseF(1,-1,1);
        phi[10]=PhaseF(-1,-1,1);
        phi[11]=PhaseF(1,1,-1);
        phi[12]=PhaseF(-1,1,-1);
        phi[13]=PhaseF(1,-1,-1);
        phi[14]=PhaseF(-1,-1,-1);
        phi[15]=PhaseF(1,1,0);
        phi[16]=PhaseF(-1,1,0);
        phi[17]=PhaseF(1,-1,0);
        phi[18]=PhaseF(-1,-1,0);
        phi[19]=PhaseF(1,0,1);
        phi[20]=PhaseF(-1,0,1);
        phi[21]=PhaseF(1,0,-1);
        phi[22]=PhaseF(-1,0,-1);
        phi[23]=PhaseF(0,1,1);
        phi[24]=PhaseF(0,-1,1);
        phi[25]=PhaseF(0,1,-1);
        phi[26]=PhaseF(0,-1,-1);

	lpPhi = 0.0;
	for (int i=0; i<27; i++){
		lpPhi += wg[i]*(phi[i] - phi[0]);
	}
	lpPhi *= 6.0;

	mu = 4.0*(12.0*sigma/Width)*(C-PhaseField_l)*(C-PhaseField_h)*(C-pfavg)
	       - (1.5 *sigma*Width) * lpPhi;

	return mu;
}

CudaDeviceFunction real_t calcGamma_g(int i, real_t u, real_t v, real_t w, real_t u2mag){
	real_t gamma, tmp;
	tmp = (d3q27_ex[i]*u+d3q27_ey[i]*v+d3q27_ez[i]*w);

	gamma = wg[i] * (1 + 3.0*(tmp) + 4.5*(tmp*tmp) - 1.5*(u2mag)) ;
	return gamma;
}

CudaDeviceFunction real_t calcGamma_h(int i, real_t u, real_t v, real_t w, real_t u2mag){
	real_t gamma, tmp;
	tmp = (d3q27_ex[i]*u+d3q27_ey[i]*v+d3q27_ez[i]*w);

	gamma = wh[i] * (1 + 3.0*(tmp) + 4.5*(tmp*tmp) - 1.5*(u2mag)) ;
	return gamma;
}

CudaDeviceFunction real_t calcF_phi(int i, real_t tmp1, real_t nx, real_t ny, real_t nz){
	real_t f_phi;

	f_phi = wh[i] * tmp1 * (d3q27_ex[i]*nx + d3q27_ey[i]*ny + d3q27_ez[i]*nz);
	return f_phi;
}

//	INITIALISATION:
CudaDeviceFunction void Init() {
	PhaseF = PhaseField;
}

CudaDeviceFunction void Init_distributions(){
// Find Gradients and normals:
	int i;
	real_t C = PhaseF(0,0,0);
	vector_t gradPhi = calcGradPhi();
	real_t nx, ny, nz, magnPhi;
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z + 1e-12);
	nx = gradPhi.x/magnPhi;
	ny = gradPhi.y/magnPhi;
	nz = gradPhi.z/magnPhi;
// Define Equilibrium, then initialise all da things
	U = VelocityX;
	V = VelocityY;
	W = VelocityZ;
	real_t mag = U*U + V*V + W*W;

	real_t Gamma[27];
// ##### heq
	real_t F_phi[15], tmp1;
	tmp1 = (1.0 - 4.0*(C - 0.5)*(C - 0.5))/Width;

	real_t h[15];
	for (i=0; i< 15; i++){
		Gamma[i] = calcGamma_h(i, U, V, W, mag);
		F_phi[i] = calcF_phi(i, tmp1, nx, ny, nz);
		h[i] = C * Gamma[i] - 0.5*F_phi[i];
	}
// ##### geq
	real_t g[27];
	for (i=0; i<27; i++){
		Gamma[i] = calcGamma_g(i, U, V, W, mag);
		g[i] = Gamma[i] - wg[i];
	}
        g0 = g[0]; 	g1 = g[1];
        g2 = g[2]; 	g3 = g[3];
        g4 = g[4]; 	g5 = g[5];
        g6 = g[6]; 	g7 = g[7];
        g8 = g[8]; 	g9 = g[9];
        g10 = g[10];    g11 = g[11];
        g12 = g[12];    g13 = g[13];
        g14 = g[14];    g15 = g[15];
        g16 = g[16];    g17 = g[17];
        g18 = g[18];    g19 = g[19];
        g20 = g[20];    g21 = g[21];
        g22 = g[22];    g23 = g[23];
        g24 = g[24];    g25 = g[25];
        g26 = g[26];
	h0 = h[0]; 	h1 = h[1];
        h2 = h[2]; 	h3 = h[3];
        h4 = h[4]; 	h5 = h[5];
        h6 = h[6]; 	h7 = h[7];
        h8 = h[8];     	h9 = h[9];
        h10 = h[10];    h11 = h[11];
        h12 = h[12];    h13 = h[13];
        h14 = h[14];
}

//	ITERATION:
CudaDeviceFunction void Run() {
    switch (NodeType & NODE_BOUNDARY) {
		case NODE_Solid:
		case NODE_Wall:
			BounceBack();
			break;
    }
    if (NodeType & NODE_MRT)
    {
		//CollisionMRT();
		//CollisionMRT_SRTstress();
    } else if (NodeType & NODE_BGK) {
		CollisionBGK();
	}
}

CudaDeviceFunction void CollisionBGK(){
	int i;
	real_t C = PhaseF(0,0,0), mu;
	real_t tau, DynVisc, rho, p;			// Macroscopic Properties
	vector_t gradPhi;				// Phase field gradients
	real_t nx, ny, nz, magnPhi;			// Normals
	real_t Gamma[27], geq[27], mag;			// equilibrium, pressure equilibrium, velocity magnitude
	real_t F_pressure[3], F_body[3], F_mu[3], F_total[3]; // Forces
	real_t tmp1, stress[6]={0.0,0.0,0.0,0.0,0.0,0.0};     // Stress tensor calculation
	real_t F_phi[15], heq[15];			// Phase field collision terms
	real_t F_i[27];					// Momentum distribution forcing term

// Find Macroscopic Details
	mu = calcMu( C );
	rho = Density_l + (C - PhaseField_l)*(Density_h - Density_l);
	p = <?R C(sum(g)) ?>;

// Temporary fix:
	real_t g[27];
        g[0] = g0;
        g[1] = g1;
        g[2] = g2;
        g[3] = g3;
        g[4] = g4;
        g[5] = g5;
        g[6] = g6;
        g[7] = g7;
        g[8] = g8;
        g[9] = g9;
        g[10] = g10;
        g[11] = g11;
        g[12] = g12;
        g[13] = g13;
        g[14] = g14;
        g[15] = g15;
        g[16] = g16;
        g[17] = g17;
        g[18] = g18;
        g[19] = g19;
        g[20] = g20;
        g[21] = g21;
        g[22] = g22;
        g[23] = g23;
        g[24] = g24;
        g[25] = g25;
        g[26] = g26;

// Updating of tau:
//    Updating via the kinematic viscosity here gives more stable solutions
//    Updating via the dynVisc section of the code is more accurate
//        but will go unstable for low viscosities
	if ( C < PhaseField_l){
		tau = tau_l + 0.5;
	} else if (C > PhaseField_h) {
		tau = tau_h + 0.5;
	} else {
		// Inverse update:
		//tau = (C - PhaseField_l)/(PhaseField_h - PhaseField_l) * (1.0/tau_h - 1.0/tau_l) + 1.0/tau_l;
		//tau = 1.0/tau + 0.5;

		// Linear update:
		tau = 0.5 + tau_l + C*(tau_h - tau_l);

		// Viscosity update:
		//DynVisc = Density_l*Viscosity_l + C * (Density_h*Viscosity_h - Density_l*Viscosity_l);
		//tau = 3.0 * DynVisc / rho + 0.5;
	}

	// GRADIENTS AND NORMALS
	gradPhi = calcGradPhi();
	magnPhi = sqrt(gradPhi.x*gradPhi.x + gradPhi.y*gradPhi.y + gradPhi.z*gradPhi.z + 1e-32);
	nx = gradPhi.x/magnPhi;
	ny = gradPhi.y/magnPhi;
	nz = gradPhi.z/magnPhi;

	// GAMMA AND EQUILIBRIUM
	mag = U*U + V*V + W*W;
	for (i=0; i< 27; i++){
		Gamma[i] = calcGamma_g(i, U, V, W, mag);
		geq[i] = wg[i]*p + Gamma[i] - wg[i];
	}

	// CALCULATE FORCES:
	F_pressure[0] = (-1.0/3.0) * p * (Density_h-Density_l) * gradPhi.x;
	F_pressure[1] = (-1.0/3.0) * p * (Density_h-Density_l) * gradPhi.y;
	F_pressure[2] = (-1.0/3.0) * p * (Density_h-Density_l) * gradPhi.z;
	F_body[0] = (rho-Density_h)*BuoyancyX + rho*GravitationX;
	F_body[1] = (rho-Density_h)*BuoyancyY + rho*GravitationY;
	F_body[2] = (rho-Density_h)*BuoyancyZ + rho*GravitationZ;
		// Stress/strain Tensor
	for (i=0; i< 27; i++){
		tmp1 = g[i] - geq[i];
		stress[0] += tmp1*d3q27_ex[i]*d3q27_ex[i];
		stress[1] += tmp1*d3q27_ex[i]*d3q27_ey[i];
		stress[2] += tmp1*d3q27_ex[i]*d3q27_ez[i];
		stress[3] += tmp1*d3q27_ey[i]*d3q27_ey[i];
		stress[4] += tmp1*d3q27_ey[i]*d3q27_ez[i];
		stress[5] += tmp1*d3q27_ez[i]*d3q27_ez[i];
	}

	F_mu[0] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y + stress[2]*gradPhi.z);
	F_mu[1] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[1]*gradPhi.x + stress[3]*gradPhi.y + stress[4]*gradPhi.z);
	F_mu[2] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[2]*gradPhi.x + stress[4]*gradPhi.y + stress[5]*gradPhi.z);
	F_total[0] = mu*gradPhi.x + F_pressure[0] + F_body[0] + F_mu[0];
	F_total[1] = mu*gradPhi.y + F_pressure[1] + F_body[1] + F_mu[1];
	F_total[2] = mu*gradPhi.z + F_pressure[2] + F_body[2] + F_mu[2];

<?R C( u, g %*% U) ?>
	U = U + (0.5*F_total[0])/rho;
	V = V + (0.5*F_total[1])/rho;
	W = W + (0.5*F_total[2])/rho;

// RECALCULATE GAMMA
	mag = U*U + V*V + W*W;
	for (i=0; i< 27; i++){
		Gamma[i] = calcGamma_g(i, U, V, W, mag);
		geq[i] = wg[i]*p + Gamma[i] - wg[i];
	}
	for (i=0;i<6;i++) {
		stress[i] = 0.0;
	}
	for (i=0; i< 27; i++){
		tmp1 = g[i] - geq[i];
		stress[0] += tmp1*d3q27_ex[i]*d3q27_ex[i];
		stress[1] += tmp1*d3q27_ex[i]*d3q27_ey[i];
		stress[2] += tmp1*d3q27_ex[i]*d3q27_ez[i];
		stress[3] += tmp1*d3q27_ey[i]*d3q27_ey[i];
		stress[4] += tmp1*d3q27_ey[i]*d3q27_ez[i];
		stress[5] += tmp1*d3q27_ez[i]*d3q27_ez[i];
	}

	F_mu[0] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[0]*gradPhi.x + stress[1]*gradPhi.y + stress[2]*gradPhi.z);
	F_mu[1] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[1]*gradPhi.x + stress[3]*gradPhi.y + stress[4]*gradPhi.z);
	F_mu[2] = (0.5-tau)/tau * (Density_h-Density_l) * (stress[2]*gradPhi.x + stress[4]*gradPhi.y + stress[5]*gradPhi.z);
	F_total[0] = mu*gradPhi.x + F_pressure[0] + F_body[0] + F_mu[0];
	F_total[1] = mu*gradPhi.y + F_pressure[1] + F_body[1] + F_mu[1];
	F_total[2] = mu*gradPhi.z + F_pressure[2] + F_body[2] + F_mu[2];

// PHASE FIELD POPULATION UPDATE:
	tmp1 = (1.0 - 4.0*(C - 0.5)*(C - 0.5))/Width;
	real_t fix[15] = {0.75, 1.5, 1.5, 1.5, 1.5, 1.5, 1.5,3.,3.,3.,3.,3.,3.,3.,3.};
	real_t h[15];
        h[0] = h0;
        h[1] = h1;
        h[2] = h2;
        h[3] = h3;
        h[4] = h4;
        h[5] = h5;
        h[6] = h6;
        h[7] = h7;
        h[8] = h8;
        h[9] = h9;
        h[10] = h10;
        h[11] = h11;
        h[12] = h12;
        h[13] = h13;
        h[14] = h14;
	for (i=0; i< 15; i++){
		F_phi[i] = calcF_phi(i, tmp1, nx, ny, nz); 		// Forcing Terms
		heq[i] = C * fix[i]*Gamma[i] - 0.5*F_phi[i];      	// heq
		h[i] = h[i] - omega_phi * (h[i]-heq[i]) + F_phi[i];	// collision
	}
// PRESSURE EVOLUTION UPDATE:
	for (i=0; i< 27; i++) {
		F_i[i] = 3.0*wg[i] * (F_total[0]*d3q27_ex[i] + F_total[1]*d3q27_ey[i] + F_total[2]*d3q27_ez[i])/rho;

		g[i] = g[i]-(g[i]-(geq[i]-0.5*F_i[i]))/tau+F_i[i]; // Collision
	}
        g0 = g[0];
        g1 = g[1];
        g2 = g[2];
        g3 = g[3];
        g4 = g[4];
        g5 = g[5];
        g6 = g[6];
        g7 = g[7];
        g8 = g[8];
        g9 = g[9];
        g10 = g[10];
        g11 = g[11];
        g12 = g[12];
        g13 = g[13];
        g14 = g[14];
        g15 = g[15];
        g16 = g[16];
        g17 = g[17];
        g18 = g[18];
        g19 = g[19];
        g20 = g[20];
        g21 = g[21];
        g22 = g[22];
        g23 = g[23];
        g24 = g[24];
        g25 = g[25];
        g26 = g[26];
        h0 = h[0];
        h1 = h[1];
        h2 = h[2];
        h3 = h[3];
        h4 = h[4];
        h5 = h[5];
        h6 = h[6];
        h7 = h[7];
        h8 = h[8];
        h9 = h[9];
        h10 = h[10];
        h11 = h[11];
        h12 = h[12];
        h13 = h[13];
        h14 = h[14];
}

//	BOUNDARY CONDITIONS:
CudaDeviceFunction void BounceBack()
{
	real_t tmp;
        tmp = g0; g0 = g0;
        tmp = g1; g1 = g2;
        tmp = g2; g2 = g1;
        tmp = g3; g3 = g4;
        tmp = g4; g4 = g3;
        tmp = g5; g5 = g6;
        tmp = g6; g6 = g5;
        tmp = g7; g7 = g14;
        tmp = g8; g8 = g13;
        tmp = g9; g9 = g12;
        tmp = g10; g10 = g11;
        tmp = g11; g11 = g10;
        tmp = g12; g12 = g9;
        tmp = g13; g13 = g8;
        tmp = g14; g14 = g7;
        tmp = g15; g15 = g18;
        tmp = g16; g16 = g17;
        tmp = g17; g17 = g16;
        tmp = g18; g18 = g15;
        tmp = g19; g19 = g22;
        tmp = g20; g20 = g21;
        tmp = g21; g21 = g20;
        tmp = g22; g22 = g19;
        tmp = g23; g23 = g26;
        tmp = g24; g24 = g25;
        tmp = g25; g25 = g24;
        tmp = g26; g26 = g23;

        tmp = h0; h0 = h0;
        tmp = h1; h1 = h2;
        tmp = h2; h2 = h1;
        tmp = h3; h3 = h4;
        tmp = h4; h4 = h3;
        tmp = h5; h5 = h6;
        tmp = h6; h6 = h5;
        tmp = h7; h7 = h14;
        tmp = h8; h8 = h13;
        tmp = h9; h9 = h12;
        tmp = h10; h10 = h11;
        tmp = h11; h11 = h10;
        tmp = h12; h12 = h9;
        tmp = h13; h13 = h8;
        tmp = h14; h14 = h7;
}

CudaDeviceFunction vector_t getA(){
	vector_t ret;
	return ret;
}
CudaDeviceFunction float2 Color() {
        float2 ret;
        vector_t u = getU();
        ret.x = sqrt(u.x*u.x + u.y*u.y);
        if (NodeType == NODE_Solid){
                ret.y = 0;
        } else {
                ret.y = 1;
        }
        return ret;
}
